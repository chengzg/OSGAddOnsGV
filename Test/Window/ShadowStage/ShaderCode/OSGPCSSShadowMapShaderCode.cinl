
static std::string _pcss_shadow_vp =
    "uniform mat4 lightPM;\n"
    "uniform float texFactor;\n"
    "varying vec4 projCoord;\n"
    "varying vec4 texPos;\n"
    "\n"
#ifndef NO_CONST_GLSL_VAR
    "const "
#endif
    "mat4 bias = mat4(0.5,0.0,0.0,0.0,0.0,0.5,0.0,0.0,0.0,0.0,0.5,0.0,0.5,0.5,0.5,1.0);\n""\n"
    "void main(void)\n"
    "{\n"
    "  vec4 realPos = gl_ModelViewMatrix * gl_Vertex;\n"
    "  projCoord = lightPM * realPos;\n"
    "  projCoord.x *= texFactor;\n"
    "  texPos = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
    "\n"
    "  projCoord = bias * projCoord;\n"
    "  texPos = bias * texPos;\n"
    "  gl_Position = ftransform();\n"
    "}\n";

static std::string _pcss_shadow_fp =
    "uniform sampler2D shadowMap;\n"
    "uniform sampler2D oldFactorMap;\n"
    "uniform float intensity;\n"
    "uniform int firstRun;\n"
    "uniform float mapSize;\n"
    "uniform float lightSize;\n"
    "uniform float xFactor;\n"
    "uniform float yFactor;\n"
    "varying vec4 projCoord;\n"
    "varying vec4 texPos;\n"
    "const float blockerSamples = 6.0;\n"
    "const float PCFsamples = 8.0;\n"
    "\n"
    "float sumBlocker(vec3 projectiveBiased, float filterWidth, float samples)\n"
    "{\n"
    "	float stepSize = 2.0 * filterWidth / samples;\n"
    "\n"
    "	projectiveBiased.xy -= vec2(filterWidth,filterWidth);\n"
    "\n"
    "      float blockerCount = 0.0;\n"
    "	float blockerSum = 0.0;\n"
    "\n"
    "	for (float i=0.0; i<samples; i += 1.0) \n"
    "	{\n"
    "           for (float j=0.0; j<samples; j += 1.0) \n"
    "		{\n"
    "			if(projectiveBiased.z > texture2D(shadowMap, projectiveBiased.xy + vec2(i*stepSize,j*stepSize)).x) \n"
    "			{\n"
    "				blockerCount += 1.0;\n"
    "				blockerSum += texture2D(shadowMap, projectiveBiased.xy + vec2(i*stepSize,j*stepSize)).x;\n"
    "			}\n"
    "       }\n"
    "	}\n"
    "\n"
    "	float result;\n"
    "	if(blockerCount > 0.0) result = blockerSum / blockerCount;\n"
    "	else result = 0.0;\n"
    "	return result;\n"
    "}\n"
    "\n"
    "float PCF(vec3 projectiveBiased, float filterWidth, float samples)\n"
    "{\n"
    "	float stepSize = 2.0 * filterWidth / samples;\n"
    "\n"
    "	projectiveBiased.xy -= vec2(filterWidth,filterWidth);\n"
    "\n"
    "   float blockerCount = 0.0;\n"
    "\n"
    "	for (float i=0.0; i<samples; i += 1.0) \n"
    "	{\n"
    "            for (float j=0.0; j<samples; j += 1.0) \n"
    "		{\n"
    "			if(projectiveBiased.z > texture2D(shadowMap, projectiveBiased.xy + vec2(i*stepSize,j*stepSize)).x) \n"
    "			{\n"
    "				blockerCount += 1.0;\n"
    "			}\n"
    "       }\n"
    "	}\n"
    "\n"
    "	float result = 1.0-((blockerCount/(samples*samples)));\n"
    "	\n"
    "	return result;\n"
    "}\n"
    "\n"
    "float estimatePenumbra(vec3 projectiveBiased, float blocker)\n"
    "{\n"
    "	float penumbra;\n"
    "	if (blocker == 0.0) penumbra = 0.0;\n"
    "	else penumbra = ((projectiveBiased.z - blocker) * lightSize) / blocker;\n"
    "\n"
    "     return penumbra;\n"
    "}\n"
    "\n"
    "\n"
    "void main(void)\n"
    "{\n"
    "	vec3 projectiveBiased = (projCoord.xyz / projCoord.q);\n"
    "\n"
    "	float blockerSearchWidth = 0.01/projectiveBiased.z;\n"
    "	float blocker = sumBlocker(projectiveBiased,blockerSearchWidth,blockerSamples);\n"
    "\n"
    "	float penumbra;\n"
    "	float shadowed;\n"
    "\n"
    "	penumbra = estimatePenumbra(projectiveBiased,blocker);\n"
    "	float maxpen = PCFsamples*(1.0/mapSize);\n"
    "	if(penumbra > maxpen) penumbra = maxpen;\n"
    "	shadowed = PCF(projectiveBiased,penumbra,PCFsamples);\n"
    "\n"
    "	shadowed = (1.0-shadowed) * intensity;\n"
    "\n"
    "	if(firstRun == 0) shadowed += texture2DProj(oldFactorMap,vec3(texPos.xy * vec2(xFactor,yFactor),texPos.w)).x;\n"
    "	\n"
    "	gl_FragColor = vec4(shadowed,0.0,0.0,1.0);\n"
    "}\n";
