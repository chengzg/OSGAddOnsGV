/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2006 by the OpenSG Forum                 *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 *   contact: dirk@opensg.org, gerrit.voss@vossg.org, jbehr@zgdv.de          *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class ShadowStage!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

#include <cstdlib>
#include <cstdio>
#include <boost/assign/list_of.hpp>

#include <OSGConfig.h>


#include <OSGGL.h>                        // Red default header
#include <OSGGL.h>                        // Blue default header
#include <OSGGL.h>                        // Green default header
#include <OSGGL.h>                        // Alpha default header

#include <OSGNode.h> // SceneRoot Class
#include <OSGNode.h> // LightNodes Class
#include <OSGNode.h> // ExcludeNodes Class

#include "OSGShadowStageBase.h"
#include "OSGShadowStage.h"

#include "boost/bind.hpp"

#ifdef WIN32 // turn off 'this' : used in base member initializer list warning
#pragma warning(disable:4355)
#endif

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::ShadowStage
    First Release of ShadowMap-Viewport. Viewport is capable to handle multiple Lights and produces ambient Shadows. Viewport uses On-Screen-rendering, so Window must not be occulled.
 */

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

/*! \var Real32          ShadowStageBase::_sfOffBias
    Offset-Bias for Polygon-Offset. Needs to be used with Polygon-Chunk
*/

/*! \var Real32          ShadowStageBase::_sfOffFactor
    Offset-Factor for Polygon-Offset. Needs to be used with Polygon-Chunk
*/

/*! \var Node *          ShadowStageBase::_sfSceneRoot
    Scene root node.
*/

/*! \var UInt32          ShadowStageBase::_sfMapSize
    
*/

/*! \var Node *          ShadowStageBase::_mfLightNodes
    
*/

/*! \var Node *          ShadowStageBase::_mfExcludeNodes
    
*/

/*! \var bool            ShadowStageBase::_sfMapAutoUpdate
    
*/

/*! \var UInt32          ShadowStageBase::_sfShadowMode
    
*/

/*! \var Real32          ShadowStageBase::_sfShadowSmoothness
    
*/

/*! \var bool            ShadowStageBase::_sfShadowOn
    
*/

/*! \var bool            ShadowStageBase::_sfAutoSearchForLights
    if enabled, all lights in the scenegraph are added to the ShadowViewport
*/

/*! \var Real32          ShadowStageBase::_sfGlobalShadowIntensity
    Used for every Light if set != 1.0
*/

/*! \var bool            ShadowStageBase::_sfFboOn
    Sometimes rendering directly into framebuffer is needed instead of using textures.
*/

/*! \var bool            ShadowStageBase::_sfAutoExcludeTransparentNodes
    Usually transparent objects do not throw shadows.
*/

/*! \var bool            ShadowStageBase::_sfDisableOccludedLights
    Check lights occlusion to disable occluded lights.
*/

/*! \var bool            ShadowStageBase::_sfRed
    Define whether the red color channel is written to.
*/

/*! \var bool            ShadowStageBase::_sfBlue
    Define whether the green color channel is written to.
*/

/*! \var bool            ShadowStageBase::_sfGreen
    Define whether the blue color channel is written to.
*/

/*! \var bool            ShadowStageBase::_sfAlpha
    Define whether the alpha color channel is written to.
*/


void ShadowStageBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "offBias",
        "Offset-Bias for Polygon-Offset. Needs to be used with Polygon-Chunk\n",
        OffBiasFieldId, OffBiasFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleOffBias),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleOffBias));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "offFactor",
        "Offset-Factor for Polygon-Offset. Needs to be used with Polygon-Chunk\n",
        OffFactorFieldId, OffFactorFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleOffFactor),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleOffFactor));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecNodePtr::Description(
        SFUnrecNodePtr::getClassType(),
        "sceneRoot",
        "Scene root node.\n",
        SceneRootFieldId, SceneRootFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleSceneRoot),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleSceneRoot));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "mapSize",
        "",
        MapSizeFieldId, MapSizeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleMapSize),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleMapSize));

    oType.addInitialDesc(pDesc);

    pDesc = new MFUnrecNodePtr::Description(
        MFUnrecNodePtr::getClassType(),
        "lightNodes",
        "",
        LightNodesFieldId, LightNodesFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleLightNodes),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleLightNodes));

    oType.addInitialDesc(pDesc);

    pDesc = new MFUnrecNodePtr::Description(
        MFUnrecNodePtr::getClassType(),
        "excludeNodes",
        "",
        ExcludeNodesFieldId, ExcludeNodesFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleExcludeNodes),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleExcludeNodes));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "mapAutoUpdate",
        "",
        MapAutoUpdateFieldId, MapAutoUpdateFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleMapAutoUpdate),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleMapAutoUpdate));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUInt32::Description(
        SFUInt32::getClassType(),
        "shadowMode",
        "",
        ShadowModeFieldId, ShadowModeFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleShadowMode),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleShadowMode));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "shadowSmoothness",
        "",
        ShadowSmoothnessFieldId, ShadowSmoothnessFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleShadowSmoothness),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleShadowSmoothness));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "shadowOn",
        "",
        ShadowOnFieldId, ShadowOnFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleShadowOn),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleShadowOn));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "autoSearchForLights",
        "if enabled, all lights in the scenegraph are added to the ShadowViewport\n",
        AutoSearchForLightsFieldId, AutoSearchForLightsFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleAutoSearchForLights),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleAutoSearchForLights));

    oType.addInitialDesc(pDesc);

    pDesc = new SFReal32::Description(
        SFReal32::getClassType(),
        "globalShadowIntensity",
        "Used for every Light if set != 1.0\n",
        GlobalShadowIntensityFieldId, GlobalShadowIntensityFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleGlobalShadowIntensity),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleGlobalShadowIntensity));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "fboOn",
        "Sometimes rendering directly into framebuffer is needed instead of using textures.\n",
        FboOnFieldId, FboOnFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleFboOn),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleFboOn));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "autoExcludeTransparentNodes",
        "Usually transparent objects do not throw shadows.\n",
        AutoExcludeTransparentNodesFieldId, AutoExcludeTransparentNodesFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleAutoExcludeTransparentNodes),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleAutoExcludeTransparentNodes));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "disableOccludedLights",
        "Check lights occlusion to disable occluded lights.\n",
        DisableOccludedLightsFieldId, DisableOccludedLightsFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleDisableOccludedLights),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleDisableOccludedLights));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "red",
        "Define whether the red color channel is written to.\n",
        RedFieldId, RedFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleRed),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleRed));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "blue",
        "Define whether the green color channel is written to.\n",
        BlueFieldId, BlueFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleBlue),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleBlue));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "green",
        "Define whether the blue color channel is written to.\n",
        GreenFieldId, GreenFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleGreen),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleGreen));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "alpha",
        "Define whether the alpha color channel is written to.\n",
        AlphaFieldId, AlphaFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&ShadowStage::editHandleAlpha),
        static_cast<FieldGetMethodSig >(&ShadowStage::getHandleAlpha));

    oType.addInitialDesc(pDesc);
}


ShadowStageBase::TypeObject ShadowStageBase::_type(
    ShadowStageBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    0,
    reinterpret_cast<PrototypeCreateF>(&ShadowStageBase::createEmptyLocal),
    ShadowStage::initMethod,
    ShadowStage::exitMethod,
    reinterpret_cast<InitalInsertDescFunc>(&ShadowStageBase::classDescInserter),
    false,
    0,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "\tname=\"ShadowStage\"\n"
    "\tparent=\"Stage\"\n"
    "\tlibrary=\"Window\"\n"
    "\tpointerfieldtypes=\"both\"\n"
    "\tstructure=\"concrete\"\n"
    "\tsystemcomponent=\"true\"\n"
    "\tparentsystemcomponent=\"true\"\n"
    "\tdecoratable=\"false\"\n"
    "\tuseLocalIncludes=\"false\"\n"
    ">\n"
    "First Release of ShadowMap-Viewport. Viewport is capable to handle multiple Lights and produces ambient Shadows. Viewport uses On-Screen-rendering, so Window must not be occulled.\n"
    "\t<Field\n"
    "\t\tname=\"offBias\"\n"
    "\t\ttype=\"Real32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"6\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tOffset-Bias for Polygon-Offset. Needs to be used with Polygon-Chunk\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"offFactor\"\n"
    "\t\ttype=\"Real32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"4\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tOffset-Factor for Polygon-Offset. Needs to be used with Polygon-Chunk\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"sceneRoot\"\n"
    "\t\ttype=\"NodePtr\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tScene root node.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"mapSize\"\n"
    "\t\ttype=\"UInt32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"512\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"lightNodes\"\n"
    "\t\ttype=\"NodePtr\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"excludeNodes\"\n"
    "\t\ttype=\"NodePtr\"\n"
    "\t\tcardinality=\"multi\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"mapAutoUpdate\"\n"
    "\t\ttype=\"bool\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"true\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"shadowMode\"\n"
    "\t\ttype=\"UInt32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"0\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"shadowSmoothness\"\n"
    "\t\ttype=\"Real32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"0.5\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"shadowOn\"\n"
    "\t\ttype=\"bool\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"true\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"autoSearchForLights\"\n"
    "\t\ttype=\"bool\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"false\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tif enabled, all lights in the scenegraph are added to the ShadowViewport\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"globalShadowIntensity\"\n"
    "\t\ttype=\"Real32\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"0.0\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tUsed for every Light if set != 1.0\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"fboOn\"\n"
    "\t\ttype=\"bool\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"true\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tSometimes rendering directly into framebuffer is needed instead of using textures.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"autoExcludeTransparentNodes\"\n"
    "\t\ttype=\"bool\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"true\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tUsually transparent objects do not throw shadows.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"disableOccludedLights\"\n"
    "\t\ttype=\"bool\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"false\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tCheck lights occlusion to disable occluded lights.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"red\"\n"
    "\t\ttype=\"bool\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_TRUE\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tDefine whether the red color channel is written to.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"blue\"\n"
    "\t\ttype=\"bool\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_TRUE\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tDefine whether the green color channel is written to.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"green\"\n"
    "\t\ttype=\"bool\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_TRUE\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tDefine whether the blue color channel is written to.\n"
    "\t</Field>\n"
    "\t<Field\n"
    "\t\tname=\"alpha\"\n"
    "\t\ttype=\"bool\"\n"
    "\t\tcardinality=\"single\"\n"
    "\t\tvisibility=\"external\"\n"
    "\t\tdefaultValue=\"GL_TRUE\"\n"
    "\t\tdefaultHeader=\"&lt;OSGGL.h&gt;\"\n"
    "\t\taccess=\"public\"\n"
    "\t>\n"
    "\tDefine whether the alpha color channel is written to.\n"
    "\t</Field>\n"
    "</FieldContainer>\n",
    "First Release of ShadowMap-Viewport. Viewport is capable to handle multiple Lights and produces ambient Shadows. Viewport uses On-Screen-rendering, so Window must not be occulled.\n"
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &ShadowStageBase::getType(void)
{
    return _type;
}

const FieldContainerType &ShadowStageBase::getType(void) const
{
    return _type;
}

UInt32 ShadowStageBase::getContainerSize(void) const
{
    return sizeof(ShadowStage);
}

/*------------------------- decorator get ------------------------------*/


SFReal32 *ShadowStageBase::editSFOffBias(void)
{
    editSField(OffBiasFieldMask);

    return &_sfOffBias;
}

const SFReal32 *ShadowStageBase::getSFOffBias(void) const
{
    return &_sfOffBias;
}


SFReal32 *ShadowStageBase::editSFOffFactor(void)
{
    editSField(OffFactorFieldMask);

    return &_sfOffFactor;
}

const SFReal32 *ShadowStageBase::getSFOffFactor(void) const
{
    return &_sfOffFactor;
}


//! Get the ShadowStage::_sfSceneRoot field.
const SFUnrecNodePtr *ShadowStageBase::getSFSceneRoot(void) const
{
    return &_sfSceneRoot;
}

SFUnrecNodePtr      *ShadowStageBase::editSFSceneRoot      (void)
{
    editSField(SceneRootFieldMask);

    return &_sfSceneRoot;
}

SFUInt32 *ShadowStageBase::editSFMapSize(void)
{
    editSField(MapSizeFieldMask);

    return &_sfMapSize;
}

const SFUInt32 *ShadowStageBase::getSFMapSize(void) const
{
    return &_sfMapSize;
}


//! Get the ShadowStage::_mfLightNodes field.
const MFUnrecNodePtr *ShadowStageBase::getMFLightNodes(void) const
{
    return &_mfLightNodes;
}

MFUnrecNodePtr      *ShadowStageBase::editMFLightNodes     (void)
{
    editMField(LightNodesFieldMask, _mfLightNodes);

    return &_mfLightNodes;
}

//! Get the ShadowStage::_mfExcludeNodes field.
const MFUnrecNodePtr *ShadowStageBase::getMFExcludeNodes(void) const
{
    return &_mfExcludeNodes;
}

MFUnrecNodePtr      *ShadowStageBase::editMFExcludeNodes   (void)
{
    editMField(ExcludeNodesFieldMask, _mfExcludeNodes);

    return &_mfExcludeNodes;
}

SFBool *ShadowStageBase::editSFMapAutoUpdate(void)
{
    editSField(MapAutoUpdateFieldMask);

    return &_sfMapAutoUpdate;
}

const SFBool *ShadowStageBase::getSFMapAutoUpdate(void) const
{
    return &_sfMapAutoUpdate;
}


SFUInt32 *ShadowStageBase::editSFShadowMode(void)
{
    editSField(ShadowModeFieldMask);

    return &_sfShadowMode;
}

const SFUInt32 *ShadowStageBase::getSFShadowMode(void) const
{
    return &_sfShadowMode;
}


SFReal32 *ShadowStageBase::editSFShadowSmoothness(void)
{
    editSField(ShadowSmoothnessFieldMask);

    return &_sfShadowSmoothness;
}

const SFReal32 *ShadowStageBase::getSFShadowSmoothness(void) const
{
    return &_sfShadowSmoothness;
}


SFBool *ShadowStageBase::editSFShadowOn(void)
{
    editSField(ShadowOnFieldMask);

    return &_sfShadowOn;
}

const SFBool *ShadowStageBase::getSFShadowOn(void) const
{
    return &_sfShadowOn;
}


SFBool *ShadowStageBase::editSFAutoSearchForLights(void)
{
    editSField(AutoSearchForLightsFieldMask);

    return &_sfAutoSearchForLights;
}

const SFBool *ShadowStageBase::getSFAutoSearchForLights(void) const
{
    return &_sfAutoSearchForLights;
}


SFReal32 *ShadowStageBase::editSFGlobalShadowIntensity(void)
{
    editSField(GlobalShadowIntensityFieldMask);

    return &_sfGlobalShadowIntensity;
}

const SFReal32 *ShadowStageBase::getSFGlobalShadowIntensity(void) const
{
    return &_sfGlobalShadowIntensity;
}


SFBool *ShadowStageBase::editSFFboOn(void)
{
    editSField(FboOnFieldMask);

    return &_sfFboOn;
}

const SFBool *ShadowStageBase::getSFFboOn(void) const
{
    return &_sfFboOn;
}


SFBool *ShadowStageBase::editSFAutoExcludeTransparentNodes(void)
{
    editSField(AutoExcludeTransparentNodesFieldMask);

    return &_sfAutoExcludeTransparentNodes;
}

const SFBool *ShadowStageBase::getSFAutoExcludeTransparentNodes(void) const
{
    return &_sfAutoExcludeTransparentNodes;
}


SFBool *ShadowStageBase::editSFDisableOccludedLights(void)
{
    editSField(DisableOccludedLightsFieldMask);

    return &_sfDisableOccludedLights;
}

const SFBool *ShadowStageBase::getSFDisableOccludedLights(void) const
{
    return &_sfDisableOccludedLights;
}


SFBool *ShadowStageBase::editSFRed(void)
{
    editSField(RedFieldMask);

    return &_sfRed;
}

const SFBool *ShadowStageBase::getSFRed(void) const
{
    return &_sfRed;
}


SFBool *ShadowStageBase::editSFBlue(void)
{
    editSField(BlueFieldMask);

    return &_sfBlue;
}

const SFBool *ShadowStageBase::getSFBlue(void) const
{
    return &_sfBlue;
}


SFBool *ShadowStageBase::editSFGreen(void)
{
    editSField(GreenFieldMask);

    return &_sfGreen;
}

const SFBool *ShadowStageBase::getSFGreen(void) const
{
    return &_sfGreen;
}


SFBool *ShadowStageBase::editSFAlpha(void)
{
    editSField(AlphaFieldMask);

    return &_sfAlpha;
}

const SFBool *ShadowStageBase::getSFAlpha(void) const
{
    return &_sfAlpha;
}




void ShadowStageBase::pushToLightNodes(Node * const value)
{
    editMField(LightNodesFieldMask, _mfLightNodes);

    _mfLightNodes.push_back(value);
}

void ShadowStageBase::assignLightNodes(const MFUnrecNodePtr    &value)
{
    MFUnrecNodePtr   ::const_iterator elemIt  =
        value.begin();
    MFUnrecNodePtr   ::const_iterator elemEnd =
        value.end  ();

    static_cast<ShadowStage *>(this)->clearLightNodes();

    while(elemIt != elemEnd)
    {
        this->pushToLightNodes(*elemIt);

        ++elemIt;
    }
}

void ShadowStageBase::removeFromLightNodes(UInt32 uiIndex)
{
    if(uiIndex < _mfLightNodes.size())
    {
        editMField(LightNodesFieldMask, _mfLightNodes);

        _mfLightNodes.erase(uiIndex);
    }
}

void ShadowStageBase::removeObjFromLightNodes(Node * const value)
{
    Int32 iElemIdx = _mfLightNodes.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(LightNodesFieldMask, _mfLightNodes);

        _mfLightNodes.erase(iElemIdx);
    }
}
void ShadowStageBase::clearLightNodes(void)
{
    editMField(LightNodesFieldMask, _mfLightNodes);


    _mfLightNodes.clear();
}

void ShadowStageBase::pushToExcludeNodes(Node * const value)
{
    editMField(ExcludeNodesFieldMask, _mfExcludeNodes);

    _mfExcludeNodes.push_back(value);
}

void ShadowStageBase::assignExcludeNodes(const MFUnrecNodePtr    &value)
{
    MFUnrecNodePtr   ::const_iterator elemIt  =
        value.begin();
    MFUnrecNodePtr   ::const_iterator elemEnd =
        value.end  ();

    static_cast<ShadowStage *>(this)->clearExcludeNodes();

    while(elemIt != elemEnd)
    {
        this->pushToExcludeNodes(*elemIt);

        ++elemIt;
    }
}

void ShadowStageBase::removeFromExcludeNodes(UInt32 uiIndex)
{
    if(uiIndex < _mfExcludeNodes.size())
    {
        editMField(ExcludeNodesFieldMask, _mfExcludeNodes);

        _mfExcludeNodes.erase(uiIndex);
    }
}

void ShadowStageBase::removeObjFromExcludeNodes(Node * const value)
{
    Int32 iElemIdx = _mfExcludeNodes.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(ExcludeNodesFieldMask, _mfExcludeNodes);

        _mfExcludeNodes.erase(iElemIdx);
    }
}
void ShadowStageBase::clearExcludeNodes(void)
{
    editMField(ExcludeNodesFieldMask, _mfExcludeNodes);


    _mfExcludeNodes.clear();
}



/*------------------------------ access -----------------------------------*/

UInt32 ShadowStageBase::getBinSize(ConstFieldMaskArg whichField)
{
    UInt32 returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (OffBiasFieldMask & whichField))
    {
        returnValue += _sfOffBias.getBinSize();
    }
    if(FieldBits::NoField != (OffFactorFieldMask & whichField))
    {
        returnValue += _sfOffFactor.getBinSize();
    }
    if(FieldBits::NoField != (SceneRootFieldMask & whichField))
    {
        returnValue += _sfSceneRoot.getBinSize();
    }
    if(FieldBits::NoField != (MapSizeFieldMask & whichField))
    {
        returnValue += _sfMapSize.getBinSize();
    }
    if(FieldBits::NoField != (LightNodesFieldMask & whichField))
    {
        returnValue += _mfLightNodes.getBinSize();
    }
    if(FieldBits::NoField != (ExcludeNodesFieldMask & whichField))
    {
        returnValue += _mfExcludeNodes.getBinSize();
    }
    if(FieldBits::NoField != (MapAutoUpdateFieldMask & whichField))
    {
        returnValue += _sfMapAutoUpdate.getBinSize();
    }
    if(FieldBits::NoField != (ShadowModeFieldMask & whichField))
    {
        returnValue += _sfShadowMode.getBinSize();
    }
    if(FieldBits::NoField != (ShadowSmoothnessFieldMask & whichField))
    {
        returnValue += _sfShadowSmoothness.getBinSize();
    }
    if(FieldBits::NoField != (ShadowOnFieldMask & whichField))
    {
        returnValue += _sfShadowOn.getBinSize();
    }
    if(FieldBits::NoField != (AutoSearchForLightsFieldMask & whichField))
    {
        returnValue += _sfAutoSearchForLights.getBinSize();
    }
    if(FieldBits::NoField != (GlobalShadowIntensityFieldMask & whichField))
    {
        returnValue += _sfGlobalShadowIntensity.getBinSize();
    }
    if(FieldBits::NoField != (FboOnFieldMask & whichField))
    {
        returnValue += _sfFboOn.getBinSize();
    }
    if(FieldBits::NoField != (AutoExcludeTransparentNodesFieldMask & whichField))
    {
        returnValue += _sfAutoExcludeTransparentNodes.getBinSize();
    }
    if(FieldBits::NoField != (DisableOccludedLightsFieldMask & whichField))
    {
        returnValue += _sfDisableOccludedLights.getBinSize();
    }
    if(FieldBits::NoField != (RedFieldMask & whichField))
    {
        returnValue += _sfRed.getBinSize();
    }
    if(FieldBits::NoField != (BlueFieldMask & whichField))
    {
        returnValue += _sfBlue.getBinSize();
    }
    if(FieldBits::NoField != (GreenFieldMask & whichField))
    {
        returnValue += _sfGreen.getBinSize();
    }
    if(FieldBits::NoField != (AlphaFieldMask & whichField))
    {
        returnValue += _sfAlpha.getBinSize();
    }

    return returnValue;
}

void ShadowStageBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (OffBiasFieldMask & whichField))
    {
        _sfOffBias.copyToBin(pMem);
    }
    if(FieldBits::NoField != (OffFactorFieldMask & whichField))
    {
        _sfOffFactor.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SceneRootFieldMask & whichField))
    {
        _sfSceneRoot.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MapSizeFieldMask & whichField))
    {
        _sfMapSize.copyToBin(pMem);
    }
    if(FieldBits::NoField != (LightNodesFieldMask & whichField))
    {
        _mfLightNodes.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ExcludeNodesFieldMask & whichField))
    {
        _mfExcludeNodes.copyToBin(pMem);
    }
    if(FieldBits::NoField != (MapAutoUpdateFieldMask & whichField))
    {
        _sfMapAutoUpdate.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShadowModeFieldMask & whichField))
    {
        _sfShadowMode.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShadowSmoothnessFieldMask & whichField))
    {
        _sfShadowSmoothness.copyToBin(pMem);
    }
    if(FieldBits::NoField != (ShadowOnFieldMask & whichField))
    {
        _sfShadowOn.copyToBin(pMem);
    }
    if(FieldBits::NoField != (AutoSearchForLightsFieldMask & whichField))
    {
        _sfAutoSearchForLights.copyToBin(pMem);
    }
    if(FieldBits::NoField != (GlobalShadowIntensityFieldMask & whichField))
    {
        _sfGlobalShadowIntensity.copyToBin(pMem);
    }
    if(FieldBits::NoField != (FboOnFieldMask & whichField))
    {
        _sfFboOn.copyToBin(pMem);
    }
    if(FieldBits::NoField != (AutoExcludeTransparentNodesFieldMask & whichField))
    {
        _sfAutoExcludeTransparentNodes.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DisableOccludedLightsFieldMask & whichField))
    {
        _sfDisableOccludedLights.copyToBin(pMem);
    }
    if(FieldBits::NoField != (RedFieldMask & whichField))
    {
        _sfRed.copyToBin(pMem);
    }
    if(FieldBits::NoField != (BlueFieldMask & whichField))
    {
        _sfBlue.copyToBin(pMem);
    }
    if(FieldBits::NoField != (GreenFieldMask & whichField))
    {
        _sfGreen.copyToBin(pMem);
    }
    if(FieldBits::NoField != (AlphaFieldMask & whichField))
    {
        _sfAlpha.copyToBin(pMem);
    }
}

void ShadowStageBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (OffBiasFieldMask & whichField))
    {
        _sfOffBias.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (OffFactorFieldMask & whichField))
    {
        _sfOffFactor.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SceneRootFieldMask & whichField))
    {
        _sfSceneRoot.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MapSizeFieldMask & whichField))
    {
        _sfMapSize.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (LightNodesFieldMask & whichField))
    {
        _mfLightNodes.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ExcludeNodesFieldMask & whichField))
    {
        _mfExcludeNodes.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (MapAutoUpdateFieldMask & whichField))
    {
        _sfMapAutoUpdate.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShadowModeFieldMask & whichField))
    {
        _sfShadowMode.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShadowSmoothnessFieldMask & whichField))
    {
        _sfShadowSmoothness.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (ShadowOnFieldMask & whichField))
    {
        _sfShadowOn.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (AutoSearchForLightsFieldMask & whichField))
    {
        _sfAutoSearchForLights.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (GlobalShadowIntensityFieldMask & whichField))
    {
        _sfGlobalShadowIntensity.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (FboOnFieldMask & whichField))
    {
        _sfFboOn.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (AutoExcludeTransparentNodesFieldMask & whichField))
    {
        _sfAutoExcludeTransparentNodes.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DisableOccludedLightsFieldMask & whichField))
    {
        _sfDisableOccludedLights.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (RedFieldMask & whichField))
    {
        _sfRed.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (BlueFieldMask & whichField))
    {
        _sfBlue.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (GreenFieldMask & whichField))
    {
        _sfGreen.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (AlphaFieldMask & whichField))
    {
        _sfAlpha.copyFromBin(pMem);
    }
}

//! create a new instance of the class
ShadowStageTransitPtr ShadowStageBase::createLocal(BitVector bFlags)
{
    ShadowStageTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyLocal(bFlags);

        fc = dynamic_pointer_cast<ShadowStage>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class
ShadowStageTransitPtr ShadowStageBase::create(void)
{
    ShadowStageTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopy();

        fc = dynamic_pointer_cast<ShadowStage>(tmpPtr);
    }

    return fc;
}

ShadowStage *ShadowStageBase::createEmptyLocal(BitVector bFlags)
{
    ShadowStage *returnValue;

    newPtr<ShadowStage>(returnValue, bFlags);

    returnValue->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

//! create an empty new instance of the class, do not copy the prototype
ShadowStage *ShadowStageBase::createEmpty(void)
{
    ShadowStage *returnValue;

    newPtr<ShadowStage>(returnValue, Thread::getCurrentLocalFlags());

    returnValue->_pFieldFlags->_bNamespaceMask &=
        ~Thread::getCurrentLocalFlags();

    return returnValue;
}


FieldContainerTransitPtr ShadowStageBase::shallowCopyLocal(
    BitVector bFlags) const
{
    ShadowStage *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const ShadowStage *>(this), bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

FieldContainerTransitPtr ShadowStageBase::shallowCopy(void) const
{
    ShadowStage *tmpPtr;

    newPtr(tmpPtr,
           dynamic_cast<const ShadowStage *>(this),
           Thread::getCurrentLocalFlags());

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~Thread::getCurrentLocalFlags();

    FieldContainerTransitPtr returnValue(tmpPtr);

    return returnValue;
}




/*------------------------- constructors ----------------------------------*/

ShadowStageBase::ShadowStageBase(void) :
    Inherited(),
    _sfOffBias                (Real32(6)),
    _sfOffFactor              (Real32(4)),
    _sfSceneRoot              (NULL),
    _sfMapSize                (UInt32(512)),
    _mfLightNodes             (),
    _mfExcludeNodes           (),
    _sfMapAutoUpdate          (bool(true)),
    _sfShadowMode             (UInt32(0)),
    _sfShadowSmoothness       (Real32(0.5)),
    _sfShadowOn               (bool(true)),
    _sfAutoSearchForLights    (bool(false)),
    _sfGlobalShadowIntensity  (Real32(0.0)),
    _sfFboOn                  (bool(true)),
    _sfAutoExcludeTransparentNodes(bool(true)),
    _sfDisableOccludedLights  (bool(false)),
    _sfRed                    (bool(GL_TRUE)),
    _sfBlue                   (bool(GL_TRUE)),
    _sfGreen                  (bool(GL_TRUE)),
    _sfAlpha                  (bool(GL_TRUE))
{
}

ShadowStageBase::ShadowStageBase(const ShadowStageBase &source) :
    Inherited(source),
    _sfOffBias                (source._sfOffBias                ),
    _sfOffFactor              (source._sfOffFactor              ),
    _sfSceneRoot              (NULL),
    _sfMapSize                (source._sfMapSize                ),
    _mfLightNodes             (),
    _mfExcludeNodes           (),
    _sfMapAutoUpdate          (source._sfMapAutoUpdate          ),
    _sfShadowMode             (source._sfShadowMode             ),
    _sfShadowSmoothness       (source._sfShadowSmoothness       ),
    _sfShadowOn               (source._sfShadowOn               ),
    _sfAutoSearchForLights    (source._sfAutoSearchForLights    ),
    _sfGlobalShadowIntensity  (source._sfGlobalShadowIntensity  ),
    _sfFboOn                  (source._sfFboOn                  ),
    _sfAutoExcludeTransparentNodes(source._sfAutoExcludeTransparentNodes),
    _sfDisableOccludedLights  (source._sfDisableOccludedLights  ),
    _sfRed                    (source._sfRed                    ),
    _sfBlue                   (source._sfBlue                   ),
    _sfGreen                  (source._sfGreen                  ),
    _sfAlpha                  (source._sfAlpha                  )
{
}


/*-------------------------- destructors ----------------------------------*/

ShadowStageBase::~ShadowStageBase(void)
{
}

void ShadowStageBase::onCreate(const ShadowStage *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {
        ShadowStage *pThis = static_cast<ShadowStage *>(this);

        pThis->setSceneRoot(source->getSceneRoot());

        MFUnrecNodePtr::const_iterator LightNodesIt  =
            source->_mfLightNodes.begin();
        MFUnrecNodePtr::const_iterator LightNodesEnd =
            source->_mfLightNodes.end  ();

        while(LightNodesIt != LightNodesEnd)
        {
            pThis->pushToLightNodes(*LightNodesIt);

            ++LightNodesIt;
        }

        MFUnrecNodePtr::const_iterator ExcludeNodesIt  =
            source->_mfExcludeNodes.begin();
        MFUnrecNodePtr::const_iterator ExcludeNodesEnd =
            source->_mfExcludeNodes.end  ();

        while(ExcludeNodesIt != ExcludeNodesEnd)
        {
            pThis->pushToExcludeNodes(*ExcludeNodesIt);

            ++ExcludeNodesIt;
        }
    }
}

GetFieldHandlePtr ShadowStageBase::getHandleOffBias         (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfOffBias,
             this->getType().getFieldDesc(OffBiasFieldId)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleOffBias        (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfOffBias,
             this->getType().getFieldDesc(OffBiasFieldId)));


    editSField(OffBiasFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleOffFactor       (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfOffFactor,
             this->getType().getFieldDesc(OffFactorFieldId)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleOffFactor      (void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfOffFactor,
             this->getType().getFieldDesc(OffFactorFieldId)));


    editSField(OffFactorFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleSceneRoot       (void) const
{
    SFUnrecNodePtr::GetHandlePtr returnValue(
        new  SFUnrecNodePtr::GetHandle(
             &_sfSceneRoot,
             this->getType().getFieldDesc(SceneRootFieldId)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleSceneRoot      (void)
{
    SFUnrecNodePtr::EditHandlePtr returnValue(
        new  SFUnrecNodePtr::EditHandle(
             &_sfSceneRoot,
             this->getType().getFieldDesc(SceneRootFieldId)));

    returnValue->setSetMethod(
        boost::bind(&ShadowStage::setSceneRoot,
                    static_cast<ShadowStage *>(this), _1));

    editSField(SceneRootFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleMapSize         (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfMapSize,
             this->getType().getFieldDesc(MapSizeFieldId)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleMapSize        (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfMapSize,
             this->getType().getFieldDesc(MapSizeFieldId)));


    editSField(MapSizeFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleLightNodes      (void) const
{
    MFUnrecNodePtr::GetHandlePtr returnValue(
        new  MFUnrecNodePtr::GetHandle(
             &_mfLightNodes,
             this->getType().getFieldDesc(LightNodesFieldId)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleLightNodes     (void)
{
    MFUnrecNodePtr::EditHandlePtr returnValue(
        new  MFUnrecNodePtr::EditHandle(
             &_mfLightNodes,
             this->getType().getFieldDesc(LightNodesFieldId)));

    returnValue->setAddMethod(
        boost::bind(&ShadowStage::pushToLightNodes,
                    static_cast<ShadowStage *>(this), _1));
    returnValue->setRemoveMethod(
        boost::bind(&ShadowStage::removeFromLightNodes,
                    static_cast<ShadowStage *>(this), _1));
    returnValue->setRemoveObjMethod(
        boost::bind(&ShadowStage::removeObjFromLightNodes,
                    static_cast<ShadowStage *>(this), _1));
    returnValue->setClearMethod(
        boost::bind(&ShadowStage::clearLightNodes,
                    static_cast<ShadowStage *>(this)));

    editMField(LightNodesFieldMask, _mfLightNodes);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleExcludeNodes    (void) const
{
    MFUnrecNodePtr::GetHandlePtr returnValue(
        new  MFUnrecNodePtr::GetHandle(
             &_mfExcludeNodes,
             this->getType().getFieldDesc(ExcludeNodesFieldId)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleExcludeNodes   (void)
{
    MFUnrecNodePtr::EditHandlePtr returnValue(
        new  MFUnrecNodePtr::EditHandle(
             &_mfExcludeNodes,
             this->getType().getFieldDesc(ExcludeNodesFieldId)));

    returnValue->setAddMethod(
        boost::bind(&ShadowStage::pushToExcludeNodes,
                    static_cast<ShadowStage *>(this), _1));
    returnValue->setRemoveMethod(
        boost::bind(&ShadowStage::removeFromExcludeNodes,
                    static_cast<ShadowStage *>(this), _1));
    returnValue->setRemoveObjMethod(
        boost::bind(&ShadowStage::removeObjFromExcludeNodes,
                    static_cast<ShadowStage *>(this), _1));
    returnValue->setClearMethod(
        boost::bind(&ShadowStage::clearExcludeNodes,
                    static_cast<ShadowStage *>(this)));

    editMField(ExcludeNodesFieldMask, _mfExcludeNodes);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleMapAutoUpdate   (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfMapAutoUpdate,
             this->getType().getFieldDesc(MapAutoUpdateFieldId)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleMapAutoUpdate  (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfMapAutoUpdate,
             this->getType().getFieldDesc(MapAutoUpdateFieldId)));


    editSField(MapAutoUpdateFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleShadowMode      (void) const
{
    SFUInt32::GetHandlePtr returnValue(
        new  SFUInt32::GetHandle(
             &_sfShadowMode,
             this->getType().getFieldDesc(ShadowModeFieldId)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleShadowMode     (void)
{
    SFUInt32::EditHandlePtr returnValue(
        new  SFUInt32::EditHandle(
             &_sfShadowMode,
             this->getType().getFieldDesc(ShadowModeFieldId)));


    editSField(ShadowModeFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleShadowSmoothness (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfShadowSmoothness,
             this->getType().getFieldDesc(ShadowSmoothnessFieldId)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleShadowSmoothness(void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfShadowSmoothness,
             this->getType().getFieldDesc(ShadowSmoothnessFieldId)));


    editSField(ShadowSmoothnessFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleShadowOn        (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfShadowOn,
             this->getType().getFieldDesc(ShadowOnFieldId)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleShadowOn       (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfShadowOn,
             this->getType().getFieldDesc(ShadowOnFieldId)));


    editSField(ShadowOnFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleAutoSearchForLights (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfAutoSearchForLights,
             this->getType().getFieldDesc(AutoSearchForLightsFieldId)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleAutoSearchForLights(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfAutoSearchForLights,
             this->getType().getFieldDesc(AutoSearchForLightsFieldId)));


    editSField(AutoSearchForLightsFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleGlobalShadowIntensity (void) const
{
    SFReal32::GetHandlePtr returnValue(
        new  SFReal32::GetHandle(
             &_sfGlobalShadowIntensity,
             this->getType().getFieldDesc(GlobalShadowIntensityFieldId)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleGlobalShadowIntensity(void)
{
    SFReal32::EditHandlePtr returnValue(
        new  SFReal32::EditHandle(
             &_sfGlobalShadowIntensity,
             this->getType().getFieldDesc(GlobalShadowIntensityFieldId)));


    editSField(GlobalShadowIntensityFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleFboOn           (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfFboOn,
             this->getType().getFieldDesc(FboOnFieldId)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleFboOn          (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfFboOn,
             this->getType().getFieldDesc(FboOnFieldId)));


    editSField(FboOnFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleAutoExcludeTransparentNodes (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfAutoExcludeTransparentNodes,
             this->getType().getFieldDesc(AutoExcludeTransparentNodesFieldId)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleAutoExcludeTransparentNodes(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfAutoExcludeTransparentNodes,
             this->getType().getFieldDesc(AutoExcludeTransparentNodesFieldId)));


    editSField(AutoExcludeTransparentNodesFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleDisableOccludedLights (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfDisableOccludedLights,
             this->getType().getFieldDesc(DisableOccludedLightsFieldId)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleDisableOccludedLights(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfDisableOccludedLights,
             this->getType().getFieldDesc(DisableOccludedLightsFieldId)));


    editSField(DisableOccludedLightsFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleRed             (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfRed,
             this->getType().getFieldDesc(RedFieldId)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleRed            (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfRed,
             this->getType().getFieldDesc(RedFieldId)));


    editSField(RedFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleBlue            (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfBlue,
             this->getType().getFieldDesc(BlueFieldId)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleBlue           (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfBlue,
             this->getType().getFieldDesc(BlueFieldId)));


    editSField(BlueFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleGreen           (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfGreen,
             this->getType().getFieldDesc(GreenFieldId)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleGreen          (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfGreen,
             this->getType().getFieldDesc(GreenFieldId)));


    editSField(GreenFieldMask);

    return returnValue;
}

GetFieldHandlePtr ShadowStageBase::getHandleAlpha           (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfAlpha,
             this->getType().getFieldDesc(AlphaFieldId)));

    return returnValue;
}

EditFieldHandlePtr ShadowStageBase::editHandleAlpha          (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfAlpha,
             this->getType().getFieldDesc(AlphaFieldId)));


    editSField(AlphaFieldMask);

    return returnValue;
}


#ifdef OSG_MT_CPTR_ASPECT
void ShadowStageBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    ShadowStage *pThis = static_cast<ShadowStage *>(this);

    pThis->execSync(static_cast<ShadowStage *>(&oFrom),
                    whichField,
                    oOffsets,
                    syncMode,
                    uiSyncInfo);
}
#endif


#ifdef OSG_MT_CPTR_ASPECT
FieldContainer *ShadowStageBase::createAspectCopy(
    const FieldContainer *pRefAspect) const
{
    ShadowStage *returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const ShadowStage *>(pRefAspect),
                  dynamic_cast<const ShadowStage *>(this));

    return returnValue;
}
#endif

void ShadowStageBase::resolveLinks(void)
{
    Inherited::resolveLinks();

    static_cast<ShadowStage *>(this)->setSceneRoot(NULL);

    static_cast<ShadowStage *>(this)->clearLightNodes();

    static_cast<ShadowStage *>(this)->clearExcludeNodes();


}


#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
DataType FieldTraits<ShadowStage *>::_type("ShadowStagePtr", "StagePtr");
#endif

OSG_FIELDTRAITS_GETTYPE(ShadowStage *)

OSG_EXPORT_PTR_SFIELD_FULL(PointerSField,
                           ShadowStage *,
                           0);

OSG_EXPORT_PTR_MFIELD_FULL(PointerMField,
                           ShadowStage *,
                           0);

OSG_END_NAMESPACE
