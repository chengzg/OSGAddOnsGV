# PyOpenSG is (C) Copyright 2005-2009 by Allen Bierbaum
#
# This file is part of PyOpenSG.
#
# PyOpenSG is free software; you can redistribute it and/or modify it under
# the terms of the GNU Lesser General Public License as published by the Free
# Software Foundation; either version 2 of the License, or (at your option)
# any later version.
#
# PyOpenSG is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
# more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#
# This script is derived from gen_bindings.py, it contains all class specific 
# tasks for the OSGBaseLib for the integration with the OpenSG CMake system
# (GV)
#

from goodies import *

import pygccxml.declarations as pd

import pyplusplus.function_transformers as FT

import osggen
import settings
import splitGenHelper

#--------------------------------------------------------------------------------------------------

gRetMF_re = re.compile('.*MF.*')

def addMyMFRetListWrapper(calldef, nakedRetType, mfIsPointer, unique_id):
   """
   Adds a custom wrapper for methods that return data through an MField. The wrapper changes the
   method return type to be a Python list of the field data.

   @type  calldef:
   @param calldef:      The declaration of the method that will be wrapped.
   @type  nakedRetType:
   @param nakedRetType: The undecorated return type. This has had cv-qualification, pointer, and
                        reference information stripped from it.
   @type  mfIsPointer:  boolean
   @param mfIsPointer:  Identifies whether the MField object returned by the method is a pointer.
   """
   class_decl = calldef.parent
   classname = class_decl.name
   fullclassname = class_decl.decl_string.lstrip(":")
   methodname = calldef.name

   # We use the actual return type from the method being invoked rather than
   # the "naked" return type. In general, this avoids copying the MField
   # object, and it allows us to use the typedef'd MField name quite easily.
   # This is important for portability reasons (in particular because GLenum,
   # as used by OSG::MFGLenum) is defined differently on different platforms.
   mftype = calldef.return_type.decl_string.lstrip(":")

   # addMyMFRetListWrapper() is used to make a C++ method returning a MField<>
   # returning a python list instead. It is used for the 'myGetMField' template
   # members. The problem is that when assigning the generated wrapper function
   # to the instanciated template method returning the MField<> the compiler
   # has no information on which of the functions to take (they have the same
   # name and different return types and arguments, but that does not matter
   # for the way boost::python assigns the functions). So it quits with a
   # 'address of overloaded function with no contextual type information' error.
   # Assigning the 'unique_id' to the wrapper function's name is a quick and
   # readable workaround for that.
   new_methodname = "%s_%s%s"%(osggen.cleanTemplateName(classname), methodname, unique_id)
   if mfIsPointer:
      get_size  = "mf_data->size()"
      get_entry = "(*mf_data)[i]"
   else:
      get_size  = "mf_data.size()"
      get_entry = "mf_data[i]"

   # Determine if the type contained in the multi-field derives from OSG::FieldContainer. If it
   # does, then we need to extend the return value conversion to wrap the C pointer in an
   # RecPtr object.
   # TODO!
   #value_type_typedef = nakedRetType.declarations.typedef(name ="value_type", allow_empty = True)
   #if value_type_typedef:
   #   field_container = OSG_MODULE.class_("FieldContainer")
   #   value_type = value_type_typedef[0].type

   #   # The actual type of value_type is probably going to be a pointer.
   #   if is_pointer(value_type):
   #      value_type = remove_pointer(value_type)

   #   if is_class(value_type):
   #      if is_base_and_derived(field_container, value_type.declaration):
   #         get_entry = "OSG::%s::ObjRecPtr(%s)" % (value_type.declaration.name, get_entry)

   args = calldef.arguments
   #for arg in args:
   #  print('Argument: ' + arg.type.decl_string)
   mf_valuetype = args[1].type.decl_string.lstrip('::')

   code = """
boost::python::list %(new_methodname)s(%(fullclassname)s *self,
                                       const std::string& name,
                                       %(mf_valuetype)s type)
{
   boost::python::list result;
   %(mftype)s mf_data = self->%(methodname)s(name, type);
   const OSG::UInt32 size(%(get_size)s);
   for ( OSG::UInt32 i = 0; i < size; ++i )
   {
      result.append(%(get_entry)s);
   }
   return result;
}""" % vars()

   class_decl.add_declaration_code(code)
   calldef.ignore = True
   print "Adding MFRetList wrapper for: %s %s"%(classname, methodname)
   add_member_function(class_decl, methodname, new_methodname)

#--------------------------------------------------------------------------------------------------

def preScanSetup(gen_classes, fc_infos, core_mods, free_funcs, free_func_mods, exc_types):

  return

def excludeFCDSetup(opensg_src_dir, fc_ignore_list, skip_fcds):

  return


cmh_ncsd_temp         = None
ftm_cmh_ncsd_temp     = None
dfc_ftm_cmh_ncsd_temp = None
sp_temp               = None

def genTemplatesSetup(template_builder, tbuilder, non_fc_template_instances):

  global cmh_ncsd_temp
  global ftm_cmh_ncsd_temp
  global dfc_ftm_cmh_ncsd_temp
  global sp_temp

  cmh_ncsd_temp         = tbuilder.Template("OSG::ContainerMixinHead<OSG::NodeCoreScriptDesc>",
                                            "ContainerMixinHeadNodeCoreScriptDesc")
  ftm_cmh_ncsd_temp     = tbuilder.Template("OSG::FrameTaskMixin<OSG::ContainerMixinHead<OSG::NodeCoreScriptDesc> >",
                                            "FrameTaskMixinContainerMixinHeadNodeCoreScriptDesc")
  dfc_ftm_cmh_ncsd_temp = tbuilder.Template("OSG::DynFieldContainer<OSG::FrameTaskMixin<OSG::ContainerMixinHead<OSG::NodeCoreScriptDesc> > >",
                                            "DynFieldContainerFrameTaskMixinContainerMixinHeadNodeCoreScriptDesc")
  sp_temp               = tbuilder.Template("OSG::ScriptParent", "ScriptParent")

  return



def postScanSetup(osg, template_alias_db):
  
  splitGenHelper.exposeTemplateType(cmh_ncsd_temp)
  splitGenHelper.exposeTemplateType(ftm_cmh_ncsd_temp)
  splitGenHelper.exposeTemplateType(dfc_ftm_cmh_ncsd_temp)
  splitGenHelper.exposeTemplateType(sp_temp)

  #----------------------------------------------------------------------------
  # PythonScript:
  #----------------------------------------------------------------------------

  sc = osg.class_("PythonScript")

  for decl in sc["getFinalType"]:
    print "getFinalType", decl
    if is_const_ref(decl.return_type):
      decl.exclude()
    else:
      decl.call_policies = return_internal_reference()

  for decl in dfc_ftm_cmh_ncsd_temp.decl["getFinalType"]:
    print "getFinalType TEMPLATE ", decl
    if is_const_ref(decl.return_type):
      decl.exclude()
    else:
      decl.call_policies = return_internal_reference()

  #----------------------------------------------------------------------------
  # ScriptBase:
  #----------------------------------------------------------------------------

  scbase = osg.class_("ScriptBase")

  # Expose static fields as properties:
  scbase.add_registration_code('add_property("priority", &OSG::ScriptBase::getPriority, &OSG::ScriptBase::setPriority)')
  scbase.add_registration_code('add_property("script", bp::make_function(&OSG::ScriptBase::getScript, bp::return_value_policy<bp::copy_const_reference>()), &OSG::ScriptBase::setScript)')

  # Expose static field masks. Masks for dynamically added fields are exposed
  # at runtime in PythonScript::addField().
  scbase.add_code('bp::scope().attr("PriorityFieldMask") = (int)OSG::TypeTraits<OSG::BitVector>::One << OSG::ScriptBase::PriorityFieldId;', False, False)
  scbase.add_code('bp::scope().attr("ScriptFieldMask") = (int)OSG::TypeTraits<OSG::BitVector>::One << OSG::ScriptBase::ScriptFieldId;', False, False)

  #----------------------------------------------------------------------------
  # PyFieldAccessHandler:
  #----------------------------------------------------------------------------

  fah = osg.class_("PyFieldAccessHandler")
  id  = 0

  for decl in fah["myGetMField"]:
    ret_type = remove_alias(decl.return_type)
    ret_naked_type = remove_cv(remove_pointer(remove_reference(ret_type)))
    rt_is_const = \
       is_const(ret_type) or (hasattr(ret_type, 'base') and is_const(ret_type.base))
    rt_is_ref = \
       is_reference(ret_type) or (hasattr(ret_type, 'base') and is_reference(ret_type.base))
    rt_is_pointer = is_pointer(ret_type)
    rt_is_class = is_class(ret_naked_type)
    rt_is_mf_type = rt_is_class and gRetMF_re.match(ret_naked_type.declaration.name)

    print "processing " + decl.name

    #if not decl.ignore and rt_is_mf_type and rt_is_const:
    addMyMFRetListWrapper(decl, ret_naked_type, rt_is_pointer, id)
    id += 1
    print("    ... adding MFWrapper")
    #else:
    #  print("    ... NOT adding MFWrapper")

  return


def tempLookatPostScanSetup(osg):

  return


def postGenClassesSetup(osg, mb):

  return


def postFCDInfoSetup(osg, mb, adddition_exp):

  #----------------------------------------------------------------------------
  # PythonScript:
  #----------------------------------------------------------------------------

  sc = osg.class_("PythonScript")

  #
  # findNamedComponent():
  #

  for decl in sc["findNamedComponent"]:
    print "changing return type of: ", decl
    print "    to return_internal_reference..."
    decl.call_policies = return_internal_reference()

  #----------------------------------------------------------------------------
  # PyFieldAccessHandler:
  #----------------------------------------------------------------------------

  sc = osg.class_("PyFieldAccessHandler")

  #
  # myEditSField():
  #

  for decl in sc["myEditSField"]:
    print "processing ", decl
    if decl.return_type.decl_string == "std::basic_string<char,std::char_traits<char>,std::allocator<char> > &":
        decl.call_policies = return_value_policy(copy_non_const_reference)
        print "    ... -> copy_non_const_reference"
        continue
    if decl.return_type.decl_string == "double &" or decl.return_type.decl_string == "int &":
        decl.call_policies = return_value_policy(return_by_value)
        print "    ... -> return_by_value"
        continue
    decl.call_policies = return_internal_reference()
    print "    ... -> return_internal_reference"

  #
  # getPointerSField():
  #

  #for decl in sc["getPointerSField"]:
  #  print "processing ", decl
  #  decl.call_policies = return_internal_reference()

  return
