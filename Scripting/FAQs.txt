/*---------------------------------------------------------------------------*/
/* FAQ document for OpenSG's Python Bindings and the PythonScript core       */
/* (This file will most likely be split into two documents when finished)    */
/*                                                                           */
/* Author: Martin Hecher                                                     */
/* E-Mail: martin.hecher@fraunhofer.sg                                       */
/*---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------*/
/* SECTION: USAGE                                                            */
/*---------------------------------------------------------------------------*/


--------------------------------------------------------------------------------
Q: Why is it not possible to replace/set a dynamic multi-field with another
   multi-field of the same type?
A: There are two problems currently:
   1. Pointer multi-fields (typed or generic FieldContainer ones) are currently
      not exported to Python. It is therefore not possible to create a pointer
      multi-field, add data to it and set it as value of a dynamic multi-field
      of the PythonScript core.
   2. Currently the access for a dynamic pointer multi-field is done via a
      custom wrapper that generically accesses the multi-field on a
      FieldContainer base. This wrapper is specific to the PythonScript
      implementation and not directly compatible with a MField<OSGTYPE> class.

   To replace or set data within a dynamic pointer multi-field you therefore
   have to use its iterator interface.
   
   In future pointer multi-fields access from Python may be available, but there
   are no current plans to implement that, as the PythonScript core is meant for
   prototyping, not for high-performance applications.
--------------------------------------------------------------------------------

Q: How to access the scene graph?
A: self.findNamedComponent()

Q: how do i access the field Ids and fieldmasks?
A: case sensitive
  -> zusammenfassen? Q: How to access data?
  
Q: How to start an application?
A: LD_LIBRARY_PATH=~/dev/Libs/install/OpenSG/lib64/debug PYTHONPATH=~/dev/Libs/install/OpenSG/lib64/python2.7/site-packages/debug OSG_LOAD_LIBS=OSGScriptingPy ./appCSM /home/hecher/dev/Projekte/OSGExt/Scripting/Example/TestSimpleAnimation



Q: How can I access the fields added to the PythonScript[File] in the .osg
   file?
A: case sensitive, testRouting shows the different access methods

Q: Are there any differences in use and behaviour of pointer multi/single-fields
   and value multi/single-fields?
   
A: pointer multi-fields: gethandle is protected against write access
   value   multi-field:  not protected, you have to take care yourself
   pointer single-field: not protected
   value   single-field: protected
   
--------------------------------------------------------------------------------
Q: Which environment variables have to be set to correctly start the "appCSM"
   application in combination with the PythonScript component?

A: There are 2 things to take care of when starting the "appCSM" application:
   1. Set the environmnet variable OSG_LOAD_LIBS="OSGScripting" to tell appCSM
      to load the OSGScripting library holding the PythonScript component.
   2. Set PYTHONPATH=<install>/lib[64]/python2.7/site-packages/{debug|opt} to
      make the python bindings accessible for the Python interpreter.

   On Linux the command to start the appCSM would be:
   "OSG_LOAD_LIBS="OSGScripting"
    PYTHONPATH=<install>/lib[64]/python2.7/site-packages/{debug|opt}
    ./appCSM <path/to/params.csm>"
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
Q: Starting my CSM application quits with the error "ImportError: No module
   named osg2.osg". What is going wrong?

A: Python cannot find the OpenSG bindings needed to use the PythonScript core.
   You have to add the bindings location to your PYTHONPATH before starting the 
   application. You have to create the PYTHONPATH environment variable (if it
   is not present yet) and add the path to the OpenSG bindings. For a default
   installation of OpenSG the path is

   Linux:   <install>/lib[64]/{debug|opt}
   Windows: TODO: where?
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
Q: The import of the OpenSG bindings within the python interpreter quits with
   the error "ImportError: libOSGBase.so.2.0.0: cannot open shared object file:
   No such file or directory". What is going wrong? (TODO: windows error)

A: Python cannot find the OpenSG libraries. You have to add the library 
   location to a path the system searches for libraries. On Linux you can use
   the LD_LIBRARY_PATH environment variable, on Windows use environment
   variables. For a default installation of OpenSG the path is

   Linux:   <install>/lib[64]/{debug|opt}
   Windows:
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
Q: Starting my CSM application quits with the error "ImportError: No module
   named osg2.osg". What is going wrong?

A: Python cannot find the OpenSG bindings needed to use the PythonScript core.
   You have to add the bindings location to your PYTHONPATH before starting the 
   application. You have to create the PYTHONPATH environment variable (if it
   is not present yet) and add the path to the OpenSG bindings. For a default
   installation of OpenSG the path is

   Linux:   <install>/lib[64]/{debug|opt}
   Windows: TODO: where?
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
Q: The import of the OpenSG bindings within the python interpreter quits with
   the error "ImportError: No module named osg2.osg". What is going wrong?

A: Python cannot find the OpenSG bindings. You have to add the bindings 
   location to your PYTHONPATH before starting the application. You have to
   create the PYTHONPATH environment variable (if it is not present yet) and
   add the path to the OpenSG bindings. For a default installation of OpenSG
   the path is 

   Linux:   <install>/lib[64]/{debug|opt}
   Windows: TODO: where?
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
Q: Why do I have to "import osg2.osg as osg" instead of "import osg"?

A: With the additional "osg2" namespace it is possible to import single OpenSG
   packages. So you can do for instance an "import osg2.OSGBase as osgbase", if
   you need to.  However, when importing single packages you have to manually 
   take care of the correct import sequence. The dependencies of the packages 
   are listed in the file ${OPENSG_ROOT}/Bindings/Python/module/__init__.py in
   the variable "osg2ModuleList" (For the curious: The file is automatically 
   generated by CMake. The responsible macro is located in 
   ${OPENSG_ROOT}/CMakeLists.txt at about line 1661 in section "Global Python").

   The "import osg2.osg as osg" statement automatically takes care of importing
   all known modules in the correct order.
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
Q: How do I use the OpenSG bindings in my Python scripts? (notwendig hier?)

A: TODO
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
Q: I can do a "import osg2.osg as osg" and initializing OpenSG with
   "osg.osgInit([])" successfully returns true. However, instanciating e.g.
   a core with "transC = osg.Transform.create()" does not create a valid
   Transform object. Why is that?

A: One possibility is that you build your OpenSG libraries static. In this case
   the Python bindings do not work.
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
Q: Why does a single-field not get changed when retrieving it with
   self.get_FIELDNAME() or via its property implementation self.FIELDNAME and
   calling a mutating method on it? This code sample shows the effect:
   scene.osg:
     ...
     field SFVec3f myVecField 1 1 1
     ...
     
   script.py:
     ...
     v = self.myVecField # or v = self.get_myVecField()
     v.setValues(2,2,2)
     print('new value: %s' % self.myVecField) # -> here the old value (1,1,1)
                                              # is printed. Why?
     ...

A: Short answer: self.myVecField or self.get_myVecField() are only returning a
   "read-only" version of the field value. To change the value use
   edit_myVecField(), e.g
     
     v = self.edit_myVecField()
     v.setValues(2,2,2)
     print('new value: %s' % self.myVecField) # -> prints (2,2,2)
     
   Long answer: Retrieving a field value either by its property or via the
   get_FIELDNAME() method does return you a copy of the value, not a reference.
   That has kind of the same effect as the C++ way, where you get a const
   reference of the value. The reason behind is that when you want to change the
   value of a field you have to tell OpenSG explicitly. Behind the scenes that
   change can then be propagated and dependent data is updated (the update is
   triggered in calling osg.commitChanges()). To tell OpenSG that you want to
   change the value and not only use it read-only you have to use the
   edit_FIELDNAME() method. It returns a reference to the value that can be
   changed and internally records that the field value has changed. The next
   osg.commitChanges() call updates dependent data.   
   
   Unfortunately there is no direct way to map the behaviour of a const reference
   value in C++ to Python for our case here. You cannot prevent a mutating
   method to be called on an object (there is no const keyword in python).
   The effect is that the interpreter does not prevent you from changing a value
   that is supposed to be read-only (and when you are familiar with the C++
   OpenSG you are used to that behaviour). Therefore the choice was made to
   return a copy to at least prevent the situation that you could change the
   value but dependent data would not be updated.
   
   The cleanest solution would be that v.setValues() is not accessible when
   retrieving the value via the get-methods. However, that is not implemented
   at this time and there are no current plans to do it.
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
Q: Why are there no edit_XXX methods for the value types Bool, Int32, UInt32,
   Int64, UInt64, Real32, Real64, Time and String?
   
A: The Python bindings do not support to return references to these types. Use
   the set_XXX methods to change the values.
--------------------------------------------------------------------------------

/*---------------------------------------------------------------------------*/
/* SECTION: BINDINGS INSTALLATION                                            */
/*---------------------------------------------------------------------------*/


--------------------------------------------------------------------------------
Q: How do I install the OpenSG Python bindings from source?

A: TODO
--------------------------------------------------------------------------------


/*---------------------------------------------------------------------------*/
/* SECTION: BINDINGS GENERATION                                              */
/*---------------------------------------------------------------------------*/


--------------------------------------------------------------------------------
Q: Generating the bindings e.g. with "make OSGBasePyGen" results in the error
   "ImportError: No module named pygccxml". What is wrong?

A: When you downloaded the trunk version of pygccxml bindings (which is most 
   probably the case as of this time pygccxml version bundled e.g. with Ubuntu 
   11.04 are not recent enough) you have to make sure that the python 
   interpreter finds them. The easiest way is to include the correct path in
   the PYTHONPATH. The path points to the directory containing the pygccxml
   sources. When you downloaded pygccxml from the subversion repository 
   described in the installation docs the path is 
   "<pygccxml-svn>/pygccxml_dev". On Linux you can start the generation step
   with "PYTHONPATH=<pygccxml-svn>/pygccxml_dev make OSGPyGen".
--------------------------------------------------------------------------------



























