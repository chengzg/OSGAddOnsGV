/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *             Copyright (C) 2000-2008 by the OpenSG Forum                   *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 *   contact: dirk@opensg.org, gerrit.voss@vossg.org, jbehr@zgdv.de          *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 \*---------------------------------------------------------------------------*/

#include "OSGSPURTTraverseCacheKD.h"

void intersectRayEnvelope(UInt32 envId, 
			  const UInt16 uiCache,
			  const UInt32 mfc_tag_id)
{
  UInt16 i,j;
  for(i = 0 ; i < envelopeTilesY ; ++i)
    {
      for(j = 0 ; j < envelopeTilesX ; ++j)
	{
	  intersectRayTileSIMD((fourHitPacket_t*)&hitEnvelope[envId].tile[i][j], 
			       (rayTile_t*)&rayEnvelope[envId].tile[i][j], 
			       (rayInfoTile_t*)&rayInfoEnvelope[envId].tile[i][j],
			       uiCache,
			       mfc_tag_id);
	}
    }
}

void intersectRayEnvelopeDoubleBuffered(rayEnvelope_t* rayEnvelope,
					rayInfoEnvelope_t* rayInfoEnvelope,
					hitEnvelope_t* hitEnvelope,
					const UInt16 uiCache,
					const UInt32 mfc_tag_id)
{
  UInt16 i,j;
  for(i = 0 ; i < envelopeTilesY ; ++i)
    {
      for(j = 0 ; j < envelopeTilesX ; ++j)
	{
	  intersectRayTileSIMD((fourHitPacket_t*)&hitEnvelope->tile[i][j], 
			       (rayTile_t*)&rayEnvelope->tile[i][j], 
			       (rayInfoTile_t*)&rayInfoEnvelope->tile[i][j],
			       uiCache,
			       mfc_tag_id);
	}
    }
}
					

void intersectRayTileSIMD(fourHitPacket_t* fourHitPacket,
			  rayTile_t* rayTile,
			  rayInfoTile_t* rayInfoTile,
			  const UInt16 uiCache,
			  const UInt32 mfc_tag_id)
{
  UInt32 uiDirSign[3];

  uiDirSign[0] = spu_c_movemask(rayTile->fDir[X]);
  uiDirSign[1] = spu_c_movemask(rayTile->fDir[Y]);
  uiDirSign[2] = spu_c_movemask(rayTile->fDir[Z]);
	  
  if (((uiDirSign[0] != 0) && (uiDirSign[0] != 15)) || 
      ((uiDirSign[1] != 0) && (uiDirSign[1] != 15)) ||
      ((uiDirSign[2] != 0) && (uiDirSign[2] != 15)))
    {
      intersectRayTileScalar((fourHitPacket_t*)&fourHitPacket,
  			     (rayTile_t*)&rayTile,
  			     (rayInfoTile_t*)&rayInfoTile,
  			     uiCache,
  			     mfc_tag_id);
      return;
    }
    
  vec_float4 tmin4       = SIMDZero;
  vec_float4 tmax4       = SIMDInfinity;
  UInt32 activeMask  = 0xf;
  UInt32 termination = 0;

  UInt16 stackIndex = 0;

  customVec4_t invDir;

  invDir.data[X] = spu_c_invert(rayTile->fDir[X]);
  invDir.data[Y] = spu_c_invert(rayTile->fDir[Y]);
  invDir.data[Z] = spu_c_invert(rayTile->fDir[Z]);

  //ClipX
  vec_float4 tmp1 = spu_splats(rootBoxVolume[uiCache].min[X]);
  vec_float4 tmp2 = spu_splats(rayTile->vOriginA[X]);

  const vec_float4 clipMinX = spu_mul(spu_sub(tmp1, tmp2), invDir.data[X]);

  const vec_float4 clipMaxX = 
    spu_mul(spu_sub(spu_splats(rootBoxVolume[uiCache].max[X]), spu_splats(rayTile->vOriginA[X])), invDir.data[X]);
  
  const vec_float4 cmpX = spu_convtf(spu_cmpgt(rayTile->fDir[X], SIMDZero), 0);

  tmin4 = spu_c_max(tmin4, spu_c_update(cmpX, clipMinX, clipMaxX));
  tmax4 = spu_c_min(tmax4, spu_c_update(cmpX, clipMaxX, clipMinX));

  // ClipY
  const vec_float4 clipMinY = 
    spu_mul(spu_sub(spu_splats(rootBoxVolume[uiCache].min[Y]), spu_splats(rayTile->vOriginA[Y])), invDir.data[Y]);
    
  const vec_float4 clipMaxY = 
    spu_mul(spu_sub(spu_splats(rootBoxVolume[uiCache].max[Y]), spu_splats(rayTile->vOriginA[Y])), invDir.data[Y]);

  const vec_float4 cmpY = spu_convtf(spu_cmpgt(rayTile->fDir[Y], SIMDZero), 0);

  tmin4 = spu_c_max(tmin4, spu_c_update(cmpY, clipMinY, clipMaxY));
  tmax4 = spu_c_min(tmax4, spu_c_update(cmpY, clipMaxY, clipMinY));

  // ClipZ
  const vec_float4 clipMinZ = 
    spu_mul(spu_sub(spu_splats(rootBoxVolume[uiCache].min[Z]), spu_splats(rayTile->vOriginA[Z])), invDir.data[Z]);
    
  const vec_float4 clipMaxZ = 
    spu_mul(spu_sub(spu_splats(rootBoxVolume[uiCache].max[Z]), spu_splats(rayTile->vOriginA[Z])), invDir.data[Z]);
    
  const vec_float4 cmpZ = spu_convtf(spu_cmpgt(rayTile->fDir[Z], SIMDZero), 0);

  tmin4 = spu_c_max(tmin4, spu_c_update(cmpZ, clipMinZ, clipMaxZ));
  tmax4 = spu_c_min(tmax4, spu_c_update(cmpZ, clipMaxZ, clipMinZ));

  activeMask = spu_c_movemask(spu_convtf(spu_cmpgt(tmax4, tmin4), 0));

  if(activeMask == 0x0) {return;} 

  union _u
  {
    cacheKDNode_t* node;
    LSA_t    addr;
  };

  union _u parent;
  union _u prevNode;

  parent.node = (cacheKDNode_t*)cacheKDNode+1;

  const EA_t eaBaseKDNodeCache = cacheInfoPack[uiCache].eaKDNodeCache;

  LSA_t lsaEndNode = (UInt32)&cacheKDNode[0]+sizeof(cacheKDNode_t)*gUiNodeLS;

  while(eaBaseKDNodeCache <= eaBaseKDNodeCache+sizeof(cacheKDNode_t)*cacheInfoPack[uiCache].uiNodes)
    {
      UInt32 belowFirst;

      while(!(parent.node->uiFlags & 3) == 3) // while not leaf
    	{
    	  Int32 axis = (parent.node->uiFlags) & 3; 
	  
    	  const vec_float4 tplane4 = spu_mul(spu_sub(spu_splats(parent.node->fSplitPos), 
  						     spu_splats(rayTile->vOriginA[axis])),
  					     invDir.data[axis]);

    	  union _u nearChild;
    	  union _u farChild;

    	  belowFirst = !uiDirSign[axis];
	  
    	  if(belowFirst > 0)
    	    {
    	      nearChild.addr = parent.addr + parent.node->uiAboveChild;
    	      farChild.addr  = parent.addr + parent.node->uiAboveChild + sizeof(cacheKDNode_t);
    	    }
    	  else
    	    {
    	      nearChild.addr = parent.addr + parent.node->uiAboveChild + sizeof(cacheKDNode_t);
    	      farChild.addr  = parent.addr + parent.node->uiAboveChild;
    	    }
    	  parent = nearChild;

    	  if(!(spu_c_movemask(spu_convtf(spu_cmpgt(tmax4, tplane4), 0)) & activeMask))
    	    {
    	      continue;
    	    }
    	  parent = farChild;  // can be removed??
	  
    	  if(!(spu_c_movemask(spu_convtf(spu_cmpgt(tplane4, tmin4), 0)) & activeMask))
    	    {
    	      continue;
    	    }
    	  KDSIMDStackElem_t otherNode;

	  otherNode.node = farChild.node;

    	  otherNode.tmin4 = spu_c_max(tplane4, tmin4);
    	  otherNode.tmax4 = tmax4;
	  otherNode.uiNodeCacheStIdx = gUiNodeCacheStIdx;
	  otherNode.uiLeafNodeStIdx = gUiLeafNodeStIdx;

	  prevNode = parent;
    	  parent = nearChild;

    	  tmax4 = spu_c_min(tplane4, tmax4);
	  
    	  activeMask = spu_c_movemask(spu_convtf(spu_cmpgt(tmax4, tmin4), 0));

    	  if(stackIndex >= 20)
    	    {
    	      printf("KD stack overflow in traversal, Ray tile skipped!\n");
  	      goto exit;  
    	    }
    	  sKDToDoStack[stackIndex]= otherNode;
    	  stackIndex++;
    	

	  if(parent.addr > lsaEndNode)
	    {
	      UInt32 offset = (parent.addr - prevNode.addr)/sizeof(cacheKDNode_t);
	      gUiNodeCacheStIdx += offset;

	      rebaseKDNodeCache(mfc_tag_id, uiCache);
	      rebasePrimIndexCache(mfc_tag_id, uiCache);
	  
	      mfc_write_tag_mask(1<<mfc_tag_id+6 | 1 << mfc_tag_id+7);
	      mfc_read_tag_status_all();
	  
	      if(belowFirst > 0)
		parent.node = (cacheKDNode_t*)cacheKDNode;
	      else
		parent.node = (cacheKDNode_t*)cacheKDNode+1;

	      lsaEndNode = (UInt32)&cacheKDNode[0]+sizeof(cacheKDNode_t)*gUiNodeLS;
	    }
	  
	}

      UInt32 nPrimitives = parent.node->uiNumPrims >> 2;
     
      // printf("found leaf\t");
     
      if(nPrimitives == 1)
  	{
  	  intersectTriangleSIMD(fourHitPacket, 
  				rayTile, 
  				uiCache, 
  				activeMask, 
  				nPrimitives,
  				&parent.node->uiSinglePrimitive,
  				triangleAccel,
  				mfc_tag_id,
  				cacheInfoPack[uiCache].eaTriCache);
  	}
      else 
  	{
	  UInt32* primIndex = (UInt32*)&primIndexArray[parent.node->pPrimitiveIdx*maxPrimInNode];
  
  	  intersectTriangleSIMD(fourHitPacket, 
  				rayTile, 
  				uiCache, 
  				activeMask, 
  				nPrimitives,
  				primIndex,
  				mfc_tag_id,
  				cacheInfoPack[uiCache].eaTriCache);
  	}
	  
      vec_float4 hits = {spu_extract(fourHitPacket->rDist, 3),  // clean this up
			 spu_extract(fourHitPacket->rDist, 2),
			 spu_extract(fourHitPacket->rDist, 1),
			 spu_extract(fourHitPacket->rDist, 0)};

      termination |= (activeMask & spu_c_movemask(spu_convtf(spu_c_cmple(hits, tmax4), 0))); 	   
      
      if(termination == 0xf)
	break;
      
      if(stackIndex > 0)
	{
	  stackIndex--;
	  KDSIMDStackElem_t otherNode = sKDToDoStack[stackIndex];

	  parent.node = otherNode.node;
	  tmin4  = otherNode.tmin4;
	  tmax4  = otherNode.tmax4;

	  gUiNodeCacheStIdx = otherNode.uiNodeCacheStIdx;
	  gUiLeafNodeStIdx = otherNode.uiLeafNodeStIdx;

	  rebaseKDNodeCache(mfc_tag_id, uiCache);
	  rebasePrimIndexCache(mfc_tag_id, uiCache);

	  mfc_write_tag_mask(1<<mfc_tag_id+6 | 1 << mfc_tag_id+7);
	  mfc_read_tag_status_all();

	  lsaEndNode = (UInt32)&cacheKDNode[0]+sizeof(cacheKDNode_t)*gUiNodeLS;
	  
	  activeMask = ~termination & spu_c_movemask(spu_convtf(spu_c_cmple(tmin4, tmax4), 0));
	}
      else
	{
	  break;
	}
    exit:
      break;
    }

}

void intersectRayTileScalar(fourHitPacket_t* fourHitPacket,
			    rayTile_t* rayTile,
			    rayInfoTile_t* rayInfoTile,
			    const UInt16 uiCache,
			    const UInt32 mfc_tag_id)
{
  printf("Ray directions scattered! Single Ray intersection\n");

  UInt16 stackIndex = 0;

  UInt16 iRay;
  for(iRay = 0 ; iRay < 4 ; ++iRay)
    {
      Real32 tmin,tmax, tminY, tmaxY, tminZ, tmaxZ;

      Real32 invDir[3];
      invDir[X] = 1 / rayTile->vDirA[X][iRay];
      invDir[Y] = 1 / rayTile->vDirA[Y][iRay];
      
      if(invDir[X] >= 0)
	{
	  tmin = (rootBoxVolume[uiCache].min[X] - rayTile->vOriginA[X]) * invDir[X];
	  tmax = (rootBoxVolume[uiCache].max[X] - rayTile->vOriginA[X]) * invDir[X];
	}
      else
	{
	  tmin = (rootBoxVolume[uiCache].max[X] - rayTile->vOriginA[X]) * invDir[X];
	  tmax = (rootBoxVolume[uiCache].min[X] - rayTile->vOriginA[X]) * invDir[X];;
	}
      if(invDir[Y] >= 0)
	{
	  tminY = (rootBoxVolume[uiCache].min[Y] - rayTile->vOriginA[Y]) * invDir[Y];
	  tmaxY = (rootBoxVolume[uiCache].max[Y] - rayTile->vOriginA[Y]) * invDir[Y];
	}
      else
	{
	  tminY = (rootBoxVolume[uiCache].max[Y] - rayTile->vOriginA[Y]) * invDir[Y];
	  tmaxY = (rootBoxVolume[uiCache].min[Y] - rayTile->vOriginA[Y]) * invDir[Y];
	}
      if( (tmin > tmaxY) || (tminY > tmax) )
	break;
      
      tmin = tminY > tmin ? tminY : tmin;
      tmax = tmaxY > tmax ? tmaxY : tmax;

      invDir[Z] = 1 / rayTile->vDirA[Z][iRay];

      if(invDir[Z] >= 0)
	{
	  tminZ = (rootBoxVolume[uiCache].min[Z] - rayTile->vOriginA[Z]) * invDir[Z];
	  tmaxZ = (rootBoxVolume[uiCache].max[Z] - rayTile->vOriginA[Z]) * invDir[Z];
	}
      else
	{
	  tminZ = (rootBoxVolume[uiCache].max[Z] - rayTile->vOriginA[Z]) * invDir[Z];
	  tmaxZ = (rootBoxVolume[uiCache].min[Z] - rayTile->vOriginA[Z]) * invDir[Z];
	}
      if( (tmin > tmaxZ) || (tminZ > tmax) )
	break;

      tmin = tminZ > tmin ? tminZ : tmin;
      tmax = tmaxZ > tmax ? tmaxZ : tmax;


      union _u
      {
	cacheKDNode_t *node;
	LSA_t    addr;
      };

      union _u parent;
      union _u prevNode;

      parent.node = (cacheKDNode_t*)cacheKDNode+1;

      const EA_t eaBaseKDNodeCache = cacheInfoPack[uiCache].eaKDNodeCache;

      LSA_t lsaEndNode = (UInt32)&cacheKDNode[0]+cacheInfoPack[uiCache].uiNodes*sizeof(cacheKDNode_t);

      while(eaBaseKDNodeCache <= eaBaseKDNodeCache+sizeof(cacheKDNode_t)*cacheInfoPack[uiCache].uiNodes)
	{
	  UInt32 belowFirst;
	  
	  while(!(parent.node->uiFlags & 3) == 3) // while not leaf
	    {
	      UInt32 axis = (parent.node->uiFlags) & 3;

	      Real32 tplane = parent.node->fSplitPos - rayTile->vOriginA[axis] * invDir[axis];

	      union _u nearChild;
	      union _u farChild;
      
	      belowFirst = rayTile->vOriginA[axis] <= parent.node->fSplitPos;

	      if(belowFirst > 0)
		{
		  nearChild.addr = parent.addr + parent.node->uiAboveChild;
		  farChild.addr  = parent.addr + parent.node->uiAboveChild + sizeof(cacheKDNode_t);
		}
	      else
		{
		  nearChild.addr = parent.addr + parent.node->uiAboveChild + sizeof(cacheKDNode_t);
		  farChild.addr  = parent.addr + parent.node->uiAboveChild;
		}

	      if(tplane >= tmax || tplane < 0)
		{
		  parent = nearChild;
		}
	      else if(tplane <= tmin)
		{
		  parent = farChild;
		}
	      KDSIMDStackElem_t otherNode;
	  
	      otherNode.node = farChild.node;
	      otherNode.tminA[iRay] = tplane;
	      otherNode.tmaxA[iRay] = tmax;
	      otherNode.uiNodeCacheStIdx = gUiNodeCacheStIdx;

	      prevNode = parent;
	      parent = nearChild;

	      tmax = tplane;

	      if(stackIndex >= 20)
		{
		  printf("KD stack overflow in traversal, Single Ray skipped!\n");
		  goto exitS;
		}
	      sKDToDoStack[stackIndex]= otherNode;
	      stackIndex++;
	    	  
	    }
	  if(parent.addr > lsaEndNode)
	    {
	      UInt32 offset = (parent.addr - prevNode.addr)/sizeof(cacheKDNode_t);
	      gUiNodeCacheStIdx += offset;

	      rebaseKDNodeCache(mfc_tag_id, uiCache);
	      rebasePrimIndexCache(mfc_tag_id, uiCache);

	      mfc_write_tag_mask(1<<mfc_tag_id+6 | 1 << mfc_tag_id+7);
	      mfc_read_tag_status_all();

	      if(belowFirst > 0)
		parent.node = (cacheKDNode_t*)cacheKDNode;
	      else
		parent.node = (cacheKDNode_t*)cacheKDNode+1;

	      lsaEndNode = (UInt32)&cacheKDNode[0]+sizeof(cacheKDNode_t)*gUiNodeLS;
	    }
	  UInt32 nPrimitives = parent.node->uiNumPrims >> 2;

	  if(nPrimitives == 1)
	    {
	      intersectTriangleScalar(fourHitPacket,
				      rayTile,
				      uiCache,
				      iRay,
				      nPrimitives,
				      &parent.node->uiSinglePrimitive,
				      mfc_tag_id,
				      cacheInfoPack[uiCache].eaTriCache);
	    }

	  else 
	    {
	      UInt32* primIndex = (UInt32*)&primIndexArray[parent.node->pPrimitiveIdx*maxPrimInNode];

	      intersectTriangleScalar(fourHitPacket, 
				      rayTile, 
				      uiCache,
				      iRay, 
				      nPrimitives,
				      primIndex,
				      mfc_tag_id,
				      cacheInfoPack[uiCache].eaTriCache);
	    }

	  if(spu_extract(fourHitPacket->rDist, iRay) <= tmax)
	    break;
	      
	  if(stackIndex > 0)
	    {
	      stackIndex--;
	      KDSIMDStackElem_t otherNode = sKDToDoStack[stackIndex];
	
	      parent.node = otherNode.node;
	      tmin  = otherNode.tminA[iRay];
	      tmax  = otherNode.tmaxA[iRay];

	      gUiNodeCacheStIdx = otherNode.uiNodeCacheStIdx;

	      rebaseKDNodeCache(mfc_tag_id, uiCache);
	      rebasePrimIndexCache(mfc_tag_id, uiCache);

	      mfc_write_tag_mask(1<<mfc_tag_id+6 | 1 << mfc_tag_id+7);
	      mfc_read_tag_status_all();

	      lsaEndNode = (UInt32)&cacheKDNode[0]+sizeof(cacheKDNode_t)*gUiNodeLS;
	    }
	  else
	    {
	      break;
	    }
	exitS:
	  break;
	}
    }
}

