/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *             Copyright (C) 2000-2008 by the OpenSG Forum                   *
 *                                                                           *
 *                            www.opensg.org                                 *
 *                                                                           *
 *   contact: dirk@opensg.org, gerrit.voss@vossg.org, jbehr@zgdv.de          *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 \*---------------------------------------------------------------------------*/

#include "OSGSPURTRayIntersect.h"


void intersectPrimaryRaysDynamic(UInt32 tag_id, const UInt32 batchCount)
{
  initPrimaryRayIntersect(tag_id);

  rayEnvelope     =(rayEnvelope_t*)_malloc_align(sizeof(rayEnvelope_t)*batchCount,6);
  rayInfoEnvelope =(rayInfoEnvelope_t*)_malloc_align(sizeof(rayInfoEnvelope_t)*batchCount, 4);
  hitEnvelope = (hitEnvelope_t*)_malloc_align(sizeof(hitEnvelope_t)*batchCount, 7);

  triangleAccel = (triangleData_t*)_malloc_align(sizeof(triangleData_t)*triLimitLS, 7);

  rayEnvelope_t* rayEnvelopeB2     =(rayEnvelope_t*)_malloc_align(sizeof(rayEnvelope_t)*batchCount,6);
  rayInfoEnvelope_t* rayInfoEnvelopeB2 =(rayInfoEnvelope_t*)_malloc_align(sizeof(rayInfoEnvelope_t)*batchCount, 4);
  hitEnvelope_t* hitEnvelopeB2 = (hitEnvelope_t*)_malloc_align(sizeof(hitEnvelope_t)*batchCount, 7);

  rayEnvelope_t* pRayEnvelopeBuffer[2];        
  rayInfoEnvelope_t* pRayInfoEnvelopeBuffer[2];
  hitEnvelope_t* pHitEnvelopeBuffer[2];

  pRayEnvelopeBuffer[0] = (rayEnvelope_t*)rayEnvelope;
  pRayEnvelopeBuffer[1] = rayEnvelopeB2;

  pRayInfoEnvelopeBuffer[0] = (rayInfoEnvelope_t*)rayInfoEnvelope;
  pRayInfoEnvelopeBuffer[1] = rayInfoEnvelopeB2;

  pHitEnvelopeBuffer[0] = (hitEnvelope_t*)hitEnvelope;
  pHitEnvelopeBuffer[1] = hitEnvelopeB2;

  char bufferSwitch = 0;
  Int32 eId[] = {-1, -1};
 
  UInt32 cache, i, e;
  for(cache = 0 ; cache < cb.uiCaches ; ++cache)
    { 
      if(cacheInfoPack[cache].uiNodes <= nodeLimitLS)   //DMA All Nodes in current cache
	{
	  gUiNodeLS = cacheInfoPack[cache].uiNodes;
	}
      else
	{
	  gUiNodeLS = nodeLimitLS;
	}
      gUiNodeCacheStIdx = 1;
      cacheKDNode = (cacheKDNode_t*)_malloc_align(sizeof(cacheKDNode_t)*gUiNodeLS, 4);
	  
      mfc_get(cacheKDNode, cacheInfoPack[cache].eaKDNodeCache, 
	      sizeof(cacheKDNode_t)*gUiNodeLS, tag_id+6, 0, 0);

      resetTriangleCache(triangleAccel);

      eId[0] = spu_read_in_mbox();

      if(eId[0] == -1)
	break;
	
      mfc_get(pRayEnvelopeBuffer[0], 
	      cb.eaRayBase+sizeof(rayEnvelope_t)*eId[0],
	      sizeof(rayEnvelope_t)*batchCount, 
	      tag_id, 0, 0);

      mfc_get(pRayInfoEnvelopeBuffer[0], 
	      cb.eaRayInfoBase+sizeof(rayInfoEnvelope_t)*eId[0],
	      sizeof(rayInfoEnvelope_t)*batchCount, 
	      tag_id+2, 0, 0);

      if(cache > 0)
      	{
      	  mfc_get(pHitEnvelopeBuffer[0], 
      		  cb.eaHitBase+sizeof(hitEnvelope_t)*eId[0], 
      		  sizeof(hitEnvelope_t)*batchCount, 
      		  tag_id+4, 0, 0);
	}
 
      eId[1] = spu_read_in_mbox();

      mfc_write_tag_mask(1<<tag_id+6);
      mfc_read_tag_status_all();  // wait for KD nodes

      initPrimIndexCache(tag_id, cache);

      UInt32 i;

      while(eId[bufferSwitch^1] >= 0)
	{
	  bufferSwitch^=1;
	  
	  mfc_get(pRayEnvelopeBuffer[bufferSwitch&1], 
		  cb.eaRayBase+sizeof(rayEnvelope_t)*eId[bufferSwitch&1],
		  sizeof(rayEnvelope_t)*batchCount, 
		  tag_id+(bufferSwitch&1), 0, 0);

			     
	  mfc_get(pRayInfoEnvelopeBuffer[bufferSwitch&1], 
		  cb.eaRayInfoBase+sizeof(rayInfoEnvelope_t)*eId[bufferSwitch&1],
		  sizeof(rayInfoEnvelope_t)*batchCount, 
		  tag_id+2+(bufferSwitch&1), 0, 0);

	  if(cache > 0)
	    {
	      mfc_write_tag_mask(1 << (tag_id+4+(bufferSwitch&1)));
	      mfc_read_tag_status_all();

	      mfc_get(pHitEnvelopeBuffer[bufferSwitch&1], 
		      cb.eaHitBase+sizeof(hitEnvelope_t)*eId[bufferSwitch&1], 
		      sizeof(hitEnvelope_t)*batchCount, 
		      tag_id+4+(bufferSwitch&1), 0, 0);

	      mfc_write_tag_mask(1 << (tag_id+(bufferSwitch^1)) | 
				 1 << (tag_id+2+(bufferSwitch^1))|
				 1 << (tag_id+4+(bufferSwitch^1)));
	      mfc_read_tag_status_all();
	    }
	  else
	    {
	      mfc_write_tag_mask(1 << (tag_id+(bufferSwitch^1)) | 
				 1 << (tag_id+2+(bufferSwitch^1))|
				 1 << (tag_id+4+(bufferSwitch^1)));
	      mfc_read_tag_status_all();
	      
	      for(i = 0 ; i < batchCount ; ++i)
		{
		  prepareHitEnvelope(pHitEnvelopeBuffer[bufferSwitch^1]+i,
				     pRayEnvelopeBuffer[bufferSwitch^1]+i,
				     pRayInfoEnvelopeBuffer[bufferSwitch^1]+i);
		}
	    }
	  for(i = 0 ; i < batchCount ; ++i)
	    {
	      intersectRayEnvelopeDoubleBuffered(pRayEnvelopeBuffer[bufferSwitch^1]+i,
						 pRayInfoEnvelopeBuffer[bufferSwitch^1]+i,
						 pHitEnvelopeBuffer[bufferSwitch^1]+i,
						 cache, 
						 tag_id);
	    }
	  mfc_put(pHitEnvelopeBuffer[bufferSwitch^1],
		  cb.eaHitBase+sizeof(hitEnvelope_t)*eId[bufferSwitch^1],
		  sizeof(hitEnvelope_t)*batchCount, 
		  tag_id+4+(bufferSwitch^1), 0, 0);

	  eId[bufferSwitch^1] = spu_read_in_mbox();
	}
      mfc_write_tag_mask(1 << tag_id+(bufferSwitch&1) | 
      			 1 << tag_id+2+(bufferSwitch&1) | 
      			 1 << tag_id+4+(bufferSwitch&1));
      mfc_read_tag_status_all();

      for(i = 0 ; i < batchCount ; ++i)
	{
	  intersectRayEnvelopeDoubleBuffered(pRayEnvelopeBuffer[bufferSwitch&1]+i,
					     pRayInfoEnvelopeBuffer[bufferSwitch&1]+i,
					     pHitEnvelopeBuffer[bufferSwitch&1]+i,
					     cache, 
					     tag_id);
	}
      mfc_put(pHitEnvelopeBuffer[bufferSwitch&1],
      	      cb.eaHitBase+sizeof(hitEnvelope_t)*eId[bufferSwitch&1],
      	      sizeof(hitEnvelope_t)*batchCount, 
      	      tag_id+4+(bufferSwitch&1), 0, 0);

      mfc_write_tag_mask(1 << tag_id+4+(bufferSwitch&1));
      mfc_read_tag_status_all();
    }
  _free_align((void*)rayEnvelopeB2);
  _free_align((void*)rayInfoEnvelopeB2);
  _free_align((void*)hitEnvelopeB2);
}


void intersectPrimaryRays(UInt32 tag_id, const UInt32 batchCount)
{
  initPrimaryRayIntersect(tag_id);

  rayEnvelope     =(rayEnvelope_t*)_malloc_align(sizeof(rayEnvelope_t)*batchCount,7);
  rayInfoEnvelope =(rayInfoEnvelope_t*)_malloc_align(sizeof(rayInfoEnvelope_t)*batchCount, 4);
  hitEnvelope = (hitEnvelope_t*)_malloc_align(sizeof(hitEnvelope_t)*batchCount, 7);
  triangleAccel = (triangleData_t*)_malloc_align(sizeof(triangleData_t)*triLimitLS, 7);

  EA_t rayEnvelopeBatchEA;
  EA_t rayInfoEnvelopeBatchEA;
  EA_t hitEnvelopeBatchEA;

  UInt32 cache, i, e;
  for(cache = 0 ; cache < cb.uiCaches ; ++cache)
    {
      if(cacheInfoPack[cache].uiNodes <= nodeLimitLS) //DMA All Nodes in current cache
	{
	  gUiNodeLS = cacheInfoPack[cache].uiNodes;
	}
      else
	{
	  gUiNodeLS = nodeLimitLS;
	}

      gUiNodeCacheStIdx = 1;
      cacheKDNode = (cacheKDNode_t*)_malloc_align(sizeof(cacheKDNode_t)*gUiNodeLS, 4);
	  
      mfc_get(cacheKDNode, cacheInfoPack[cache].eaKDNodeCache, 
	      sizeof(cacheKDNode_t)*gUiNodeLS, tag_id+6, 0, 0);

      resetTriangleCache(triangleAccel);

#ifdef OSG_XCACHEKD
      updateBoxVolumeCache(tag_id, cache);
#endif

      rayEnvelopeBatchEA = cb.eaRayEnvelope;
      rayInfoEnvelopeBatchEA = cb.eaRayInfoEnvelope;
      hitEnvelopeBatchEA = cb.eaHitEnvelope;

      mfc_write_tag_mask(1<<tag_id+6);
      mfc_read_tag_status_all();

      initPrimIndexCache(tag_id, cache);

      for(i = 0 ; cb.uiAssignedEnvelopes-i > batchCount ; i=i+batchCount)
	{
	  mfc_get(rayEnvelope, rayEnvelopeBatchEA, sizeof(rayEnvelope_t)*batchCount, tag_id,0,0);
	
	  mfc_get(rayInfoEnvelope, 
		  rayInfoEnvelopeBatchEA, 
		  sizeof(rayInfoEnvelope_t)*batchCount, 
		  tag_id+2, 0, 0);

	  mfc_write_tag_mask(1<<tag_id | 1<<tag_id+2);
	  mfc_read_tag_status_all();
	  
	  if(cache > 0) //multiple caches, hitenvelopes need to be loaded from main storage
	    {
	      mfc_get(hitEnvelope, 
		      hitEnvelopeBatchEA, 
		      sizeof(hitEnvelope_t)*batchCount, 
		      tag_id, 0, 0);
	      mfc_write_tag_mask(1<<tag_id+4);
	      mfc_read_tag_status_all();
	    }
	  else
	    {
	      for(e = 0 ; e < batchCount ; ++e)
		{
		  prepareHitEnvelope((hitEnvelope_t*)hitEnvelope+e,
				     (rayEnvelope_t*)rayEnvelope+e,
				     (rayInfoEnvelope_t*)rayInfoEnvelope+e);
		}
	    }
#ifdef OSG_XCACHEKD
	  mfc_write_tag_mask(1<<tag_id+9);
	  mfc_read_tag_status_all();
#endif

	  for(e = 0 ; e < batchCount ; ++e)
	    {
#ifdef OSG_XCACHEKD
	      intersectXRayEnvelope(e, cache, tag_id);
#else
	      intersectRayEnvelope(e, cache, tag_id);
#endif
	    }
	  mfc_put(hitEnvelope ,hitEnvelopeBatchEA, sizeof(hitEnvelope_t)*batchCount, tag_id, 0, 0);
	  mfc_write_tag_mask(1<<tag_id+4);
	  mfc_read_tag_status_all();
	
	  rayEnvelopeBatchEA     += batchCount*sizeof(rayEnvelope_t);
	  rayInfoEnvelopeBatchEA += batchCount*sizeof(rayInfoEnvelope_t);
	  hitEnvelopeBatchEA     += batchCount*sizeof(hitEnvelope_t);
	}
      // Two debug funtions, dumps kd cache context to console
      //printXCache(cache);
      // printCache();

      UInt16 lastBatch = cb.uiAssignedEnvelopes - i;
  
      for(e=0 ; e < lastBatch ; e++)
	{
	  if(cache > 0)
	    {
	      mfc_get(hitEnvelope, 
		      hitEnvelopeBatchEA, 
		      sizeof(hitEnvelope_t)*lastBatch,
		      tag_id, 0, 0);
	      mfc_write_tag_mask(1<<tag_id+4);
	      mfc_read_tag_status_all();
	    }
	  else
	    {
	      for(e = 0 ; e < lastBatch ; e++)
		{
		  prepareHitEnvelope((hitEnvelope_t*)hitEnvelope+e,
				     (rayEnvelope_t*)rayEnvelope+e,
				     (rayInfoEnvelope_t*)rayInfoEnvelope+e);
		}
	    
	    }
#ifdef OSG_XCACHEKD
	  intersectXRayEnvelope(e, cache, tag_id);
#else
	  intersectRayEnvelope(e, cache, tag_id);
#endif
	}
      mfc_put(hitEnvelope, hitEnvelopeBatchEA, sizeof(hitEnvelope_t)*lastBatch, tag_id, 0, 0);
      mfc_write_tag_mask(1<<tag_id);
      mfc_read_tag_status_all();
    }
}


void initPrimaryRayIntersect(UInt32 tag_id)
{
  rootBoxVolume =(boxVolume_t*)_malloc_align(sizeof(boxVolume_t)*cb.uiCaches, 5);
  
  spu_mfcdma64(rootBoxVolume, 
	       mfc_ea2h(cb.eaCacheBoxVolume), 
	       mfc_ea2l(cb.eaCacheBoxVolume),
	       sizeof(boxVolume_t)*cb.uiCaches,
	       tag_id,
	       MFC_GET_CMD);
 
  cacheInfoPack =(cacheInfoPack_t*)_malloc_align(sizeof(cacheInfoPack_t)*cb.uiCaches, 5);
  
  spu_mfcdma64(cacheInfoPack, 
	       mfc_ea2h(cb.eaCacheInfoPack), 
	       mfc_ea2l(cb.eaCacheInfoPack),
	       sizeof(cacheInfoPack_t)*cb.uiCaches,
	       tag_id+1,
	       MFC_GET_CMD);
  

  mfc_write_tag_mask(1<<tag_id | 1<<tag_id+1);
  mfc_read_tag_status_all();

}


void rebaseKDNodeCache(const UInt32 tag_id, const UInt32 uiCache)
{
  
  printf("re-basing KDNode Cache\n");

  if(gUiNodeCacheStIdx % 2 != 0)
    gUiNodeCacheStIdx--;

  UInt32 msNodesAbove = cacheInfoPack[uiCache].uiNodes-gUiNodeCacheStIdx;

  assert(msNodesAbove % 2 == 0); //must be even number so nodes are fetched in couples

  if(msNodesAbove <= nodeLimitLS)
    {
      mfc_get(cacheKDNode, cacheInfoPack[uiCache].eaKDNodeCache+sizeof(cacheKDNode_t)*gUiNodeCacheStIdx, 
	      sizeof(cacheKDNode_t)*msNodesAbove, tag_id+6, 0, 0);
     
      gUiNodeLS = msNodesAbove;
    }
  else
    {
      mfc_get(cacheKDNode, cacheInfoPack[uiCache].eaKDNodeCache+sizeof(cacheKDNode_t)*gUiNodeCacheStIdx,  
	      sizeof(cacheKDNode_t)*nodeLimitLS, tag_id+6, 0, 0);

      gUiNodeLS = nodeLimitLS;
    }

}

void initPrimIndexCache(const UInt32 tag_id, const UInt32 uiCache)
{
  UInt32 leafsInLS = 0;
  
  UInt32 i;
  for(i = 0 ; i < gUiNodeLS ; ++i)
    {
      if((cacheKDNode[i].uiFlags & 3) == 3)
	leafsInLS++; 
    }
 
  UInt32 arrayLength = leafsInLS*maxPrimInNode;

  primIndexArray = (UInt32*)_calloc_align(arrayLength, sizeof(UInt32), 4);

  spu_mfcdma64(primIndexArray, 
	       mfc_ea2h(cacheInfoPack[uiCache].eaPrimIndexArray), 
	       mfc_ea2l(cacheInfoPack[uiCache].eaPrimIndexArray),
	       arrayLength*sizeof(UInt32),
	       tag_id+7,
	       MFC_GET_CMD);

}

  //
  // Funtion should be called after every change/update of KD Node cache
void rebasePrimIndexCache(const UInt32 tag_id, const UInt32 uiCache)
{
  printf("re-basing Prim Index Cache\n");

  UInt32 leafsInLS = 0;
  
  gUiLeafNodeStIdx = gUiNodeCacheStIdx;

  UInt32 i = 0;
  while(i < gUiNodeLS)
    {
      if(((cacheKDNode[i].uiFlags & 3) == 3))
	{
	  gUiLeafNodeStIdx +=i;
	  break;
	}
      i++;
    }
  
  for(i = 0 ; i < gUiNodeLS ; ++i)
    {
      if((cacheKDNode[i].uiFlags & 3) == 3)
	leafsInLS++; 
    }
  UInt32 arraySize = sizeof(UInt32)*leafsInLS*maxPrimInNode;

  primIndexArray = (UInt32*)_realloc_align((void*)primIndexArray, arraySize, 4);

  EA_t eaPrimIndex = cacheInfoPack[uiCache].eaPrimIndexArray+sizeof(UInt32)*gUiLeafNodeStIdx*maxPrimInNode;

  if(leafsInLS > 0)
    {
      spu_mfcdma64(primIndexArray, 
		   mfc_ea2h(eaPrimIndex), 
		   mfc_ea2l(eaPrimIndex),
		   arraySize,
		   tag_id+7,
		   MFC_GET_CMD);
    }
}

