/*---------------------------------------------------------------------------*\
 *                                OpenSG                                     *
 *                                                                           *
 *                                                                           *
 *               Copyright (C) 2000-2008 by the OpenSG Forum                 *
 *                                                                           *
 *   contact: dirk@opensg.org, gerrit.voss@vossg.org, jbehr@zgdv.de          *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU Library General Public License as published    *
 * by the Free Software Foundation, version 2.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU Library General Public         *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

#include <stdio.h>
#include <spu_mfcio.h>

#include "OSGSPURTMain.h"
#include "OSGCellRTMFCHelper.h"
#include "OSGSPURTRaySetup.h"
#include "OSGSPURTRayIntersect.h"
#include "OSGCellRT.h"

//extern volatile control_block_t       cb               __attribute__ ((aligned (128)));
// extern volatile envelopeInfo_t*       envelopeInfo;
// extern volatile rayEnvelope_t*        rayEnvelope;
// extern volatile rayInfoEnvelope_t*    rayInfoEnvelope;
// extern volatile hitEnvelope_t*        hitEnvelope;
// extern volatile triangleData_t*       triangleAccel;
// extern volatile raySetupBase_t*       raySetupBase;


void flushLocalStore()
{
  _free_align((void*)rayEnvelope);
  _free_align((void*)envelopeInfo);
  _free_align((void*)rayInfoEnvelope);
  _free_align((void*)hitEnvelope);
  _free_align((void*)rootBoxVolume);
  _free_align((void*)raySetupBase);
  _free_align((void*)triangleAccel);
  _free_align((void*)cacheKDNode);
  _free_align((void*)cacheInfoPack);

#ifdef OSG_XCACHEKD
  _free_align((void*)boxVolumeCache);
#endif

}

void printControlBlock()
{
  printf("SPE %u cb: 0x%llx 0x%llx %u %u %u 0x%llx \n\t  0x%llx %u 0x%llx 0x%llx 0x%llx\n",
	 cb.speId,
	 cb.eaRayEnvelope,
	 cb.eaRayInfoEnvelope,
	 cb.uiVEnvelopesTarget,
	 cb.uiHEnvelopesTarget,
	 cb.uiAssignedEnvelopes,
	 cb.eaPrimRaySetupPack,
	 cb.eaEnvelopeInfo,
	 cb.uiCaches,
	 cb.eaCacheBoxVolume,
	 cb.eaHitEnvelope,
	 cb.eaCacheInfoPack);
}

int main(unsigned long long spe_id __attribute__ ((unused)), 
	 unsigned long long argp, 
	 unsigned long long envp __attribute__ ((unused)))
{
  UInt32 tag_id = mfc_multi_tag_reserve(10);

  assert(tag_id   != MFC_TAG_INVALID);
  

#ifdef DOUBLEBUFFER
  const UInt32 uiBatchCount =(UInt32)(1*1024)/sizeof(rayEnvelope_t);
#else
  const UInt32 uiBatchCount =(UInt32)(2*1024)/sizeof(rayEnvelope_t);
#endif

  while(TRUE)
    {
      assert(spu_stat_in_mbox() == 0);

      while(spu_stat_in_mbox() < 1);   // wait for initial signal from PPU
      UInt32 tmp = spu_read_in_mbox(); // pop Mailbox

#ifdef SINGLEFRAME
      spu_writech(SPU_WrDec, -1);
      unsigned int decrTime = spu_readch(SPU_RdDec);
#endif

#if 0
      mfc_checkDMAParams((UInt64)&cb, argp, sizeof(cb));
#endif
 
      mfc_get(&cb, argp, sizeof(cb), tag_id, 0, 0);
      mfc_write_tag_mask(1<<tag_id);
      mfc_read_tag_status_all();

#ifdef SINGLEFRAME
      printControlBlock();
#endif

#ifdef DOUBLEBUFFER
      setupPrimaryRaysDB(tag_id, uiBatchCount);
#else
      setupPrimaryRays(tag_id, uiBatchCount);
#endif

      spu_write_out_mbox(10+cb.speId); // Tell PPE ray setup is completed

      flushLocalStore();

      // Wait for go on intersection
      while(spu_stat_in_mbox() < 1);
      tmp = spu_read_in_mbox();

#ifdef DYNAMIC_ENV_ASSIGNMENT
      intersectPrimaryRaysDynamic(tag_id, uiBatchCount);
#else
      intersectPrimaryRays(tag_id, uiBatchCount);
#endif

#ifdef SINGLEFRAME
      double time = 1.0*(decrTime - spu_readch(SPU_RdDec))/ 79800000.0;

      printf("SPE %d runtime: %f\n", cb.speId, time);
#endif
      spu_write_out_mbox(20+cb.speId); // Send signal 'done' to PPU

      flushLocalStore();
    }
  return 0;
}

